// WARNING: This file was generated automatically using gen_swizzle.rs. Don't modify

use crate::vec::{PolyVec2, PolyVec3, PolyVec4, W, X, Y, Z};

// ---------- 2-Component Swizzle ----------

pub trait XX<T> {
    fn xx(&self) -> PolyVec2<T>;
}
impl<S, T> XX<T> for S
where
    S: X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.x())
    }
}
pub trait XY<T> {
    fn xy(&self) -> PolyVec2<T>;
}
impl<S, T> XY<T> for S
where
    S: X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.y())
    }
}
pub trait XZ<T> {
    fn xz(&self) -> PolyVec2<T>;
}
impl<S, T> XZ<T> for S
where
    S: X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.z())
    }
}
pub trait XW<T> {
    fn xw(&self) -> PolyVec2<T>;
}
impl<S, T> XW<T> for S
where
    S: X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xw(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.w())
    }
}
pub trait YX<T> {
    fn yx(&self) -> PolyVec2<T>;
}
impl<S, T> YX<T> for S
where
    S: Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.x())
    }
}
pub trait YY<T> {
    fn yy(&self) -> PolyVec2<T>;
}
impl<S, T> YY<T> for S
where
    S: Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.y())
    }
}
pub trait YZ<T> {
    fn yz(&self) -> PolyVec2<T>;
}
impl<S, T> YZ<T> for S
where
    S: Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.z())
    }
}
pub trait YW<T> {
    fn yw(&self) -> PolyVec2<T>;
}
impl<S, T> YW<T> for S
where
    S: Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yw(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.w())
    }
}
pub trait ZX<T> {
    fn zx(&self) -> PolyVec2<T>;
}
impl<S, T> ZX<T> for S
where
    S: Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.x())
    }
}
pub trait ZY<T> {
    fn zy(&self) -> PolyVec2<T>;
}
impl<S, T> ZY<T> for S
where
    S: Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.y())
    }
}
pub trait ZZ<T> {
    fn zz(&self) -> PolyVec2<T>;
}
impl<S, T> ZZ<T> for S
where
    S: Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.z())
    }
}
pub trait ZW<T> {
    fn zw(&self) -> PolyVec2<T>;
}
impl<S, T> ZW<T> for S
where
    S: Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zw(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.w())
    }
}
pub trait WX<T> {
    fn wx(&self) -> PolyVec2<T>;
}
impl<S, T> WX<T> for S
where
    S: W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.x())
    }
}
pub trait WY<T> {
    fn wy(&self) -> PolyVec2<T>;
}
impl<S, T> WY<T> for S
where
    S: W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.y())
    }
}
pub trait WZ<T> {
    fn wz(&self) -> PolyVec2<T>;
}
impl<S, T> WZ<T> for S
where
    S: W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.z())
    }
}
pub trait WW<T> {
    fn ww(&self) -> PolyVec2<T>;
}
impl<S, T> WW<T> for S
where
    S: W<T>,
    T: Copy,
{
    #[inline(always)]
    fn ww(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.w())
    }
}

// ---------- 3-Component Swizzle ----------

pub trait XXX<T> {
    fn xxx(&self) -> PolyVec3<T>;
}
impl<S, T> XXX<T> for S
where
    S: X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.x())
    }
}
pub trait XXY<T> {
    fn xxy(&self) -> PolyVec3<T>;
}
impl<S, T> XXY<T> for S
where
    S: X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.y())
    }
}
pub trait XXZ<T> {
    fn xxz(&self) -> PolyVec3<T>;
}
impl<S, T> XXZ<T> for S
where
    S: X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.z())
    }
}
pub trait XXW<T> {
    fn xxw(&self) -> PolyVec3<T>;
}
impl<S, T> XXW<T> for S
where
    S: X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.w())
    }
}
pub trait XYX<T> {
    fn xyx(&self) -> PolyVec3<T>;
}
impl<S, T> XYX<T> for S
where
    S: X<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.x())
    }
}
pub trait XYY<T> {
    fn xyy(&self) -> PolyVec3<T>;
}
impl<S, T> XYY<T> for S
where
    S: X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.y())
    }
}
pub trait XYZ<T> {
    fn xyz(&self) -> PolyVec3<T>;
}
impl<S, T> XYZ<T> for S
where
    S: X<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.z())
    }
}
pub trait XYW<T> {
    fn xyw(&self) -> PolyVec3<T>;
}
impl<S, T> XYW<T> for S
where
    S: X<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.w())
    }
}
pub trait XZX<T> {
    fn xzx(&self) -> PolyVec3<T>;
}
impl<S, T> XZX<T> for S
where
    S: X<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.x())
    }
}
pub trait XZY<T> {
    fn xzy(&self) -> PolyVec3<T>;
}
impl<S, T> XZY<T> for S
where
    S: X<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.y())
    }
}
pub trait XZZ<T> {
    fn xzz(&self) -> PolyVec3<T>;
}
impl<S, T> XZZ<T> for S
where
    S: X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.z())
    }
}
pub trait XZW<T> {
    fn xzw(&self) -> PolyVec3<T>;
}
impl<S, T> XZW<T> for S
where
    S: X<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.w())
    }
}
pub trait XWX<T> {
    fn xwx(&self) -> PolyVec3<T>;
}
impl<S, T> XWX<T> for S
where
    S: X<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.x())
    }
}
pub trait XWY<T> {
    fn xwy(&self) -> PolyVec3<T>;
}
impl<S, T> XWY<T> for S
where
    S: X<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.y())
    }
}
pub trait XWZ<T> {
    fn xwz(&self) -> PolyVec3<T>;
}
impl<S, T> XWZ<T> for S
where
    S: X<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.z())
    }
}
pub trait XWW<T> {
    fn xww(&self) -> PolyVec3<T>;
}
impl<S, T> XWW<T> for S
where
    S: X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xww(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.w())
    }
}
pub trait YXX<T> {
    fn yxx(&self) -> PolyVec3<T>;
}
impl<S, T> YXX<T> for S
where
    S: Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.x())
    }
}
pub trait YXY<T> {
    fn yxy(&self) -> PolyVec3<T>;
}
impl<S, T> YXY<T> for S
where
    S: Y<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.y())
    }
}
pub trait YXZ<T> {
    fn yxz(&self) -> PolyVec3<T>;
}
impl<S, T> YXZ<T> for S
where
    S: Y<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.z())
    }
}
pub trait YXW<T> {
    fn yxw(&self) -> PolyVec3<T>;
}
impl<S, T> YXW<T> for S
where
    S: Y<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.w())
    }
}
pub trait YYX<T> {
    fn yyx(&self) -> PolyVec3<T>;
}
impl<S, T> YYX<T> for S
where
    S: Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.x())
    }
}
pub trait YYY<T> {
    fn yyy(&self) -> PolyVec3<T>;
}
impl<S, T> YYY<T> for S
where
    S: Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.y())
    }
}
pub trait YYZ<T> {
    fn yyz(&self) -> PolyVec3<T>;
}
impl<S, T> YYZ<T> for S
where
    S: Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.z())
    }
}
pub trait YYW<T> {
    fn yyw(&self) -> PolyVec3<T>;
}
impl<S, T> YYW<T> for S
where
    S: Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.w())
    }
}
pub trait YZX<T> {
    fn yzx(&self) -> PolyVec3<T>;
}
impl<S, T> YZX<T> for S
where
    S: Y<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.x())
    }
}
pub trait YZY<T> {
    fn yzy(&self) -> PolyVec3<T>;
}
impl<S, T> YZY<T> for S
where
    S: Y<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.y())
    }
}
pub trait YZZ<T> {
    fn yzz(&self) -> PolyVec3<T>;
}
impl<S, T> YZZ<T> for S
where
    S: Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.z())
    }
}
pub trait YZW<T> {
    fn yzw(&self) -> PolyVec3<T>;
}
impl<S, T> YZW<T> for S
where
    S: Y<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.w())
    }
}
pub trait YWX<T> {
    fn ywx(&self) -> PolyVec3<T>;
}
impl<S, T> YWX<T> for S
where
    S: Y<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.x())
    }
}
pub trait YWY<T> {
    fn ywy(&self) -> PolyVec3<T>;
}
impl<S, T> YWY<T> for S
where
    S: Y<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.y())
    }
}
pub trait YWZ<T> {
    fn ywz(&self) -> PolyVec3<T>;
}
impl<S, T> YWZ<T> for S
where
    S: Y<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.z())
    }
}
pub trait YWW<T> {
    fn yww(&self) -> PolyVec3<T>;
}
impl<S, T> YWW<T> for S
where
    S: Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yww(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.w())
    }
}
pub trait ZXX<T> {
    fn zxx(&self) -> PolyVec3<T>;
}
impl<S, T> ZXX<T> for S
where
    S: Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.x())
    }
}
pub trait ZXY<T> {
    fn zxy(&self) -> PolyVec3<T>;
}
impl<S, T> ZXY<T> for S
where
    S: Z<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.y())
    }
}
pub trait ZXZ<T> {
    fn zxz(&self) -> PolyVec3<T>;
}
impl<S, T> ZXZ<T> for S
where
    S: Z<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.z())
    }
}
pub trait ZXW<T> {
    fn zxw(&self) -> PolyVec3<T>;
}
impl<S, T> ZXW<T> for S
where
    S: Z<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.w())
    }
}
pub trait ZYX<T> {
    fn zyx(&self) -> PolyVec3<T>;
}
impl<S, T> ZYX<T> for S
where
    S: Z<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.x())
    }
}
pub trait ZYY<T> {
    fn zyy(&self) -> PolyVec3<T>;
}
impl<S, T> ZYY<T> for S
where
    S: Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.y())
    }
}
pub trait ZYZ<T> {
    fn zyz(&self) -> PolyVec3<T>;
}
impl<S, T> ZYZ<T> for S
where
    S: Z<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.z())
    }
}
pub trait ZYW<T> {
    fn zyw(&self) -> PolyVec3<T>;
}
impl<S, T> ZYW<T> for S
where
    S: Z<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.w())
    }
}
pub trait ZZX<T> {
    fn zzx(&self) -> PolyVec3<T>;
}
impl<S, T> ZZX<T> for S
where
    S: Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.x())
    }
}
pub trait ZZY<T> {
    fn zzy(&self) -> PolyVec3<T>;
}
impl<S, T> ZZY<T> for S
where
    S: Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.y())
    }
}
pub trait ZZZ<T> {
    fn zzz(&self) -> PolyVec3<T>;
}
impl<S, T> ZZZ<T> for S
where
    S: Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.z())
    }
}
pub trait ZZW<T> {
    fn zzw(&self) -> PolyVec3<T>;
}
impl<S, T> ZZW<T> for S
where
    S: Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.w())
    }
}
pub trait ZWX<T> {
    fn zwx(&self) -> PolyVec3<T>;
}
impl<S, T> ZWX<T> for S
where
    S: Z<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.x())
    }
}
pub trait ZWY<T> {
    fn zwy(&self) -> PolyVec3<T>;
}
impl<S, T> ZWY<T> for S
where
    S: Z<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.y())
    }
}
pub trait ZWZ<T> {
    fn zwz(&self) -> PolyVec3<T>;
}
impl<S, T> ZWZ<T> for S
where
    S: Z<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.z())
    }
}
pub trait ZWW<T> {
    fn zww(&self) -> PolyVec3<T>;
}
impl<S, T> ZWW<T> for S
where
    S: Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zww(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.w())
    }
}
pub trait WXX<T> {
    fn wxx(&self) -> PolyVec3<T>;
}
impl<S, T> WXX<T> for S
where
    S: W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.x())
    }
}
pub trait WXY<T> {
    fn wxy(&self) -> PolyVec3<T>;
}
impl<S, T> WXY<T> for S
where
    S: W<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.y())
    }
}
pub trait WXZ<T> {
    fn wxz(&self) -> PolyVec3<T>;
}
impl<S, T> WXZ<T> for S
where
    S: W<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.z())
    }
}
pub trait WXW<T> {
    fn wxw(&self) -> PolyVec3<T>;
}
impl<S, T> WXW<T> for S
where
    S: W<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.w())
    }
}
pub trait WYX<T> {
    fn wyx(&self) -> PolyVec3<T>;
}
impl<S, T> WYX<T> for S
where
    S: W<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.x())
    }
}
pub trait WYY<T> {
    fn wyy(&self) -> PolyVec3<T>;
}
impl<S, T> WYY<T> for S
where
    S: W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.y())
    }
}
pub trait WYZ<T> {
    fn wyz(&self) -> PolyVec3<T>;
}
impl<S, T> WYZ<T> for S
where
    S: W<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.z())
    }
}
pub trait WYW<T> {
    fn wyw(&self) -> PolyVec3<T>;
}
impl<S, T> WYW<T> for S
where
    S: W<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.w())
    }
}
pub trait WZX<T> {
    fn wzx(&self) -> PolyVec3<T>;
}
impl<S, T> WZX<T> for S
where
    S: W<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.x())
    }
}
pub trait WZY<T> {
    fn wzy(&self) -> PolyVec3<T>;
}
impl<S, T> WZY<T> for S
where
    S: W<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.y())
    }
}
pub trait WZZ<T> {
    fn wzz(&self) -> PolyVec3<T>;
}
impl<S, T> WZZ<T> for S
where
    S: W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.z())
    }
}
pub trait WZW<T> {
    fn wzw(&self) -> PolyVec3<T>;
}
impl<S, T> WZW<T> for S
where
    S: W<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.w())
    }
}
pub trait WWX<T> {
    fn wwx(&self) -> PolyVec3<T>;
}
impl<S, T> WWX<T> for S
where
    S: W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.x())
    }
}
pub trait WWY<T> {
    fn wwy(&self) -> PolyVec3<T>;
}
impl<S, T> WWY<T> for S
where
    S: W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.y())
    }
}
pub trait WWZ<T> {
    fn wwz(&self) -> PolyVec3<T>;
}
impl<S, T> WWZ<T> for S
where
    S: W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.z())
    }
}
pub trait WWW<T> {
    fn www(&self) -> PolyVec3<T>;
}
impl<S, T> WWW<T> for S
where
    S: W<T>,
    T: Copy,
{
    #[inline(always)]
    fn www(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.w())
    }
}

// ---------- 4-Component Swizzle ----------

pub trait XXXX<T> {
    fn xxxx(&self) -> PolyVec4<T>;
}
impl<S, T> XXXX<T> for S
where
    S: X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.x())
    }
}
pub trait XXXY<T> {
    fn xxxy(&self) -> PolyVec4<T>;
}
impl<S, T> XXXY<T> for S
where
    S: X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.y())
    }
}
pub trait XXXZ<T> {
    fn xxxz(&self) -> PolyVec4<T>;
}
impl<S, T> XXXZ<T> for S
where
    S: X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.z())
    }
}
pub trait XXXW<T> {
    fn xxxw(&self) -> PolyVec4<T>;
}
impl<S, T> XXXW<T> for S
where
    S: X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.w())
    }
}
pub trait XXYX<T> {
    fn xxyx(&self) -> PolyVec4<T>;
}
impl<S, T> XXYX<T> for S
where
    S: X<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.x())
    }
}
pub trait XXYY<T> {
    fn xxyy(&self) -> PolyVec4<T>;
}
impl<S, T> XXYY<T> for S
where
    S: X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.y())
    }
}
pub trait XXYZ<T> {
    fn xxyz(&self) -> PolyVec4<T>;
}
impl<S, T> XXYZ<T> for S
where
    S: X<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.z())
    }
}
pub trait XXYW<T> {
    fn xxyw(&self) -> PolyVec4<T>;
}
impl<S, T> XXYW<T> for S
where
    S: X<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.w())
    }
}
pub trait XXZX<T> {
    fn xxzx(&self) -> PolyVec4<T>;
}
impl<S, T> XXZX<T> for S
where
    S: X<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.x())
    }
}
pub trait XXZY<T> {
    fn xxzy(&self) -> PolyVec4<T>;
}
impl<S, T> XXZY<T> for S
where
    S: X<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.y())
    }
}
pub trait XXZZ<T> {
    fn xxzz(&self) -> PolyVec4<T>;
}
impl<S, T> XXZZ<T> for S
where
    S: X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.z())
    }
}
pub trait XXZW<T> {
    fn xxzw(&self) -> PolyVec4<T>;
}
impl<S, T> XXZW<T> for S
where
    S: X<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.w())
    }
}
pub trait XXWX<T> {
    fn xxwx(&self) -> PolyVec4<T>;
}
impl<S, T> XXWX<T> for S
where
    S: X<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.x())
    }
}
pub trait XXWY<T> {
    fn xxwy(&self) -> PolyVec4<T>;
}
impl<S, T> XXWY<T> for S
where
    S: X<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.y())
    }
}
pub trait XXWZ<T> {
    fn xxwz(&self) -> PolyVec4<T>;
}
impl<S, T> XXWZ<T> for S
where
    S: X<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.z())
    }
}
pub trait XXWW<T> {
    fn xxww(&self) -> PolyVec4<T>;
}
impl<S, T> XXWW<T> for S
where
    S: X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.w())
    }
}
pub trait XYXX<T> {
    fn xyxx(&self) -> PolyVec4<T>;
}
impl<S, T> XYXX<T> for S
where
    S: X<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.x())
    }
}
pub trait XYXY<T> {
    fn xyxy(&self) -> PolyVec4<T>;
}
impl<S, T> XYXY<T> for S
where
    S: X<T> + Y<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.y())
    }
}
pub trait XYXZ<T> {
    fn xyxz(&self) -> PolyVec4<T>;
}
impl<S, T> XYXZ<T> for S
where
    S: X<T> + Y<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.z())
    }
}
pub trait XYXW<T> {
    fn xyxw(&self) -> PolyVec4<T>;
}
impl<S, T> XYXW<T> for S
where
    S: X<T> + Y<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.w())
    }
}
pub trait XYYX<T> {
    fn xyyx(&self) -> PolyVec4<T>;
}
impl<S, T> XYYX<T> for S
where
    S: X<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.x())
    }
}
pub trait XYYY<T> {
    fn xyyy(&self) -> PolyVec4<T>;
}
impl<S, T> XYYY<T> for S
where
    S: X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.y())
    }
}
pub trait XYYZ<T> {
    fn xyyz(&self) -> PolyVec4<T>;
}
impl<S, T> XYYZ<T> for S
where
    S: X<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.z())
    }
}
pub trait XYYW<T> {
    fn xyyw(&self) -> PolyVec4<T>;
}
impl<S, T> XYYW<T> for S
where
    S: X<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.w())
    }
}
pub trait XYZX<T> {
    fn xyzx(&self) -> PolyVec4<T>;
}
impl<S, T> XYZX<T> for S
where
    S: X<T> + Y<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.x())
    }
}
pub trait XYZY<T> {
    fn xyzy(&self) -> PolyVec4<T>;
}
impl<S, T> XYZY<T> for S
where
    S: X<T> + Y<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.y())
    }
}
pub trait XYZZ<T> {
    fn xyzz(&self) -> PolyVec4<T>;
}
impl<S, T> XYZZ<T> for S
where
    S: X<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.z())
    }
}
pub trait XYZW<T> {
    fn xyzw(&self) -> PolyVec4<T>;
}
impl<S, T> XYZW<T> for S
where
    S: X<T> + Y<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.w())
    }
}
pub trait XYWX<T> {
    fn xywx(&self) -> PolyVec4<T>;
}
impl<S, T> XYWX<T> for S
where
    S: X<T> + Y<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.x())
    }
}
pub trait XYWY<T> {
    fn xywy(&self) -> PolyVec4<T>;
}
impl<S, T> XYWY<T> for S
where
    S: X<T> + Y<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.y())
    }
}
pub trait XYWZ<T> {
    fn xywz(&self) -> PolyVec4<T>;
}
impl<S, T> XYWZ<T> for S
where
    S: X<T> + Y<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.z())
    }
}
pub trait XYWW<T> {
    fn xyww(&self) -> PolyVec4<T>;
}
impl<S, T> XYWW<T> for S
where
    S: X<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.w())
    }
}
pub trait XZXX<T> {
    fn xzxx(&self) -> PolyVec4<T>;
}
impl<S, T> XZXX<T> for S
where
    S: X<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.x())
    }
}
pub trait XZXY<T> {
    fn xzxy(&self) -> PolyVec4<T>;
}
impl<S, T> XZXY<T> for S
where
    S: X<T> + Z<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.y())
    }
}
pub trait XZXZ<T> {
    fn xzxz(&self) -> PolyVec4<T>;
}
impl<S, T> XZXZ<T> for S
where
    S: X<T> + Z<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.z())
    }
}
pub trait XZXW<T> {
    fn xzxw(&self) -> PolyVec4<T>;
}
impl<S, T> XZXW<T> for S
where
    S: X<T> + Z<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.w())
    }
}
pub trait XZYX<T> {
    fn xzyx(&self) -> PolyVec4<T>;
}
impl<S, T> XZYX<T> for S
where
    S: X<T> + Z<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.x())
    }
}
pub trait XZYY<T> {
    fn xzyy(&self) -> PolyVec4<T>;
}
impl<S, T> XZYY<T> for S
where
    S: X<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.y())
    }
}
pub trait XZYZ<T> {
    fn xzyz(&self) -> PolyVec4<T>;
}
impl<S, T> XZYZ<T> for S
where
    S: X<T> + Z<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.z())
    }
}
pub trait XZYW<T> {
    fn xzyw(&self) -> PolyVec4<T>;
}
impl<S, T> XZYW<T> for S
where
    S: X<T> + Z<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.w())
    }
}
pub trait XZZX<T> {
    fn xzzx(&self) -> PolyVec4<T>;
}
impl<S, T> XZZX<T> for S
where
    S: X<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.x())
    }
}
pub trait XZZY<T> {
    fn xzzy(&self) -> PolyVec4<T>;
}
impl<S, T> XZZY<T> for S
where
    S: X<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.y())
    }
}
pub trait XZZZ<T> {
    fn xzzz(&self) -> PolyVec4<T>;
}
impl<S, T> XZZZ<T> for S
where
    S: X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.z())
    }
}
pub trait XZZW<T> {
    fn xzzw(&self) -> PolyVec4<T>;
}
impl<S, T> XZZW<T> for S
where
    S: X<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.w())
    }
}
pub trait XZWX<T> {
    fn xzwx(&self) -> PolyVec4<T>;
}
impl<S, T> XZWX<T> for S
where
    S: X<T> + Z<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.x())
    }
}
pub trait XZWY<T> {
    fn xzwy(&self) -> PolyVec4<T>;
}
impl<S, T> XZWY<T> for S
where
    S: X<T> + Z<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.y())
    }
}
pub trait XZWZ<T> {
    fn xzwz(&self) -> PolyVec4<T>;
}
impl<S, T> XZWZ<T> for S
where
    S: X<T> + Z<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.z())
    }
}
pub trait XZWW<T> {
    fn xzww(&self) -> PolyVec4<T>;
}
impl<S, T> XZWW<T> for S
where
    S: X<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.w())
    }
}
pub trait XWXX<T> {
    fn xwxx(&self) -> PolyVec4<T>;
}
impl<S, T> XWXX<T> for S
where
    S: X<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.x())
    }
}
pub trait XWXY<T> {
    fn xwxy(&self) -> PolyVec4<T>;
}
impl<S, T> XWXY<T> for S
where
    S: X<T> + W<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.y())
    }
}
pub trait XWXZ<T> {
    fn xwxz(&self) -> PolyVec4<T>;
}
impl<S, T> XWXZ<T> for S
where
    S: X<T> + W<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.z())
    }
}
pub trait XWXW<T> {
    fn xwxw(&self) -> PolyVec4<T>;
}
impl<S, T> XWXW<T> for S
where
    S: X<T> + W<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.w())
    }
}
pub trait XWYX<T> {
    fn xwyx(&self) -> PolyVec4<T>;
}
impl<S, T> XWYX<T> for S
where
    S: X<T> + W<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.x())
    }
}
pub trait XWYY<T> {
    fn xwyy(&self) -> PolyVec4<T>;
}
impl<S, T> XWYY<T> for S
where
    S: X<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.y())
    }
}
pub trait XWYZ<T> {
    fn xwyz(&self) -> PolyVec4<T>;
}
impl<S, T> XWYZ<T> for S
where
    S: X<T> + W<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.z())
    }
}
pub trait XWYW<T> {
    fn xwyw(&self) -> PolyVec4<T>;
}
impl<S, T> XWYW<T> for S
where
    S: X<T> + W<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.w())
    }
}
pub trait XWZX<T> {
    fn xwzx(&self) -> PolyVec4<T>;
}
impl<S, T> XWZX<T> for S
where
    S: X<T> + W<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.x())
    }
}
pub trait XWZY<T> {
    fn xwzy(&self) -> PolyVec4<T>;
}
impl<S, T> XWZY<T> for S
where
    S: X<T> + W<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.y())
    }
}
pub trait XWZZ<T> {
    fn xwzz(&self) -> PolyVec4<T>;
}
impl<S, T> XWZZ<T> for S
where
    S: X<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.z())
    }
}
pub trait XWZW<T> {
    fn xwzw(&self) -> PolyVec4<T>;
}
impl<S, T> XWZW<T> for S
where
    S: X<T> + W<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.w())
    }
}
pub trait XWWX<T> {
    fn xwwx(&self) -> PolyVec4<T>;
}
impl<S, T> XWWX<T> for S
where
    S: X<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.x())
    }
}
pub trait XWWY<T> {
    fn xwwy(&self) -> PolyVec4<T>;
}
impl<S, T> XWWY<T> for S
where
    S: X<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.y())
    }
}
pub trait XWWZ<T> {
    fn xwwz(&self) -> PolyVec4<T>;
}
impl<S, T> XWWZ<T> for S
where
    S: X<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.z())
    }
}
pub trait XWWW<T> {
    fn xwww(&self) -> PolyVec4<T>;
}
impl<S, T> XWWW<T> for S
where
    S: X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn xwww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.w())
    }
}
pub trait YXXX<T> {
    fn yxxx(&self) -> PolyVec4<T>;
}
impl<S, T> YXXX<T> for S
where
    S: Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.x())
    }
}
pub trait YXXY<T> {
    fn yxxy(&self) -> PolyVec4<T>;
}
impl<S, T> YXXY<T> for S
where
    S: Y<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.y())
    }
}
pub trait YXXZ<T> {
    fn yxxz(&self) -> PolyVec4<T>;
}
impl<S, T> YXXZ<T> for S
where
    S: Y<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.z())
    }
}
pub trait YXXW<T> {
    fn yxxw(&self) -> PolyVec4<T>;
}
impl<S, T> YXXW<T> for S
where
    S: Y<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.w())
    }
}
pub trait YXYX<T> {
    fn yxyx(&self) -> PolyVec4<T>;
}
impl<S, T> YXYX<T> for S
where
    S: Y<T> + X<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.x())
    }
}
pub trait YXYY<T> {
    fn yxyy(&self) -> PolyVec4<T>;
}
impl<S, T> YXYY<T> for S
where
    S: Y<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.y())
    }
}
pub trait YXYZ<T> {
    fn yxyz(&self) -> PolyVec4<T>;
}
impl<S, T> YXYZ<T> for S
where
    S: Y<T> + X<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.z())
    }
}
pub trait YXYW<T> {
    fn yxyw(&self) -> PolyVec4<T>;
}
impl<S, T> YXYW<T> for S
where
    S: Y<T> + X<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.w())
    }
}
pub trait YXZX<T> {
    fn yxzx(&self) -> PolyVec4<T>;
}
impl<S, T> YXZX<T> for S
where
    S: Y<T> + X<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.x())
    }
}
pub trait YXZY<T> {
    fn yxzy(&self) -> PolyVec4<T>;
}
impl<S, T> YXZY<T> for S
where
    S: Y<T> + X<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.y())
    }
}
pub trait YXZZ<T> {
    fn yxzz(&self) -> PolyVec4<T>;
}
impl<S, T> YXZZ<T> for S
where
    S: Y<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.z())
    }
}
pub trait YXZW<T> {
    fn yxzw(&self) -> PolyVec4<T>;
}
impl<S, T> YXZW<T> for S
where
    S: Y<T> + X<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.w())
    }
}
pub trait YXWX<T> {
    fn yxwx(&self) -> PolyVec4<T>;
}
impl<S, T> YXWX<T> for S
where
    S: Y<T> + X<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.x())
    }
}
pub trait YXWY<T> {
    fn yxwy(&self) -> PolyVec4<T>;
}
impl<S, T> YXWY<T> for S
where
    S: Y<T> + X<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.y())
    }
}
pub trait YXWZ<T> {
    fn yxwz(&self) -> PolyVec4<T>;
}
impl<S, T> YXWZ<T> for S
where
    S: Y<T> + X<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.z())
    }
}
pub trait YXWW<T> {
    fn yxww(&self) -> PolyVec4<T>;
}
impl<S, T> YXWW<T> for S
where
    S: Y<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.w())
    }
}
pub trait YYXX<T> {
    fn yyxx(&self) -> PolyVec4<T>;
}
impl<S, T> YYXX<T> for S
where
    S: Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.x())
    }
}
pub trait YYXY<T> {
    fn yyxy(&self) -> PolyVec4<T>;
}
impl<S, T> YYXY<T> for S
where
    S: Y<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.y())
    }
}
pub trait YYXZ<T> {
    fn yyxz(&self) -> PolyVec4<T>;
}
impl<S, T> YYXZ<T> for S
where
    S: Y<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.z())
    }
}
pub trait YYXW<T> {
    fn yyxw(&self) -> PolyVec4<T>;
}
impl<S, T> YYXW<T> for S
where
    S: Y<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.w())
    }
}
pub trait YYYX<T> {
    fn yyyx(&self) -> PolyVec4<T>;
}
impl<S, T> YYYX<T> for S
where
    S: Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.x())
    }
}
pub trait YYYY<T> {
    fn yyyy(&self) -> PolyVec4<T>;
}
impl<S, T> YYYY<T> for S
where
    S: Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.y())
    }
}
pub trait YYYZ<T> {
    fn yyyz(&self) -> PolyVec4<T>;
}
impl<S, T> YYYZ<T> for S
where
    S: Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.z())
    }
}
pub trait YYYW<T> {
    fn yyyw(&self) -> PolyVec4<T>;
}
impl<S, T> YYYW<T> for S
where
    S: Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.w())
    }
}
pub trait YYZX<T> {
    fn yyzx(&self) -> PolyVec4<T>;
}
impl<S, T> YYZX<T> for S
where
    S: Y<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.x())
    }
}
pub trait YYZY<T> {
    fn yyzy(&self) -> PolyVec4<T>;
}
impl<S, T> YYZY<T> for S
where
    S: Y<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.y())
    }
}
pub trait YYZZ<T> {
    fn yyzz(&self) -> PolyVec4<T>;
}
impl<S, T> YYZZ<T> for S
where
    S: Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.z())
    }
}
pub trait YYZW<T> {
    fn yyzw(&self) -> PolyVec4<T>;
}
impl<S, T> YYZW<T> for S
where
    S: Y<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.w())
    }
}
pub trait YYWX<T> {
    fn yywx(&self) -> PolyVec4<T>;
}
impl<S, T> YYWX<T> for S
where
    S: Y<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.x())
    }
}
pub trait YYWY<T> {
    fn yywy(&self) -> PolyVec4<T>;
}
impl<S, T> YYWY<T> for S
where
    S: Y<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.y())
    }
}
pub trait YYWZ<T> {
    fn yywz(&self) -> PolyVec4<T>;
}
impl<S, T> YYWZ<T> for S
where
    S: Y<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.z())
    }
}
pub trait YYWW<T> {
    fn yyww(&self) -> PolyVec4<T>;
}
impl<S, T> YYWW<T> for S
where
    S: Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.w())
    }
}
pub trait YZXX<T> {
    fn yzxx(&self) -> PolyVec4<T>;
}
impl<S, T> YZXX<T> for S
where
    S: Y<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.x())
    }
}
pub trait YZXY<T> {
    fn yzxy(&self) -> PolyVec4<T>;
}
impl<S, T> YZXY<T> for S
where
    S: Y<T> + Z<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.y())
    }
}
pub trait YZXZ<T> {
    fn yzxz(&self) -> PolyVec4<T>;
}
impl<S, T> YZXZ<T> for S
where
    S: Y<T> + Z<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.z())
    }
}
pub trait YZXW<T> {
    fn yzxw(&self) -> PolyVec4<T>;
}
impl<S, T> YZXW<T> for S
where
    S: Y<T> + Z<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.w())
    }
}
pub trait YZYX<T> {
    fn yzyx(&self) -> PolyVec4<T>;
}
impl<S, T> YZYX<T> for S
where
    S: Y<T> + Z<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.x())
    }
}
pub trait YZYY<T> {
    fn yzyy(&self) -> PolyVec4<T>;
}
impl<S, T> YZYY<T> for S
where
    S: Y<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.y())
    }
}
pub trait YZYZ<T> {
    fn yzyz(&self) -> PolyVec4<T>;
}
impl<S, T> YZYZ<T> for S
where
    S: Y<T> + Z<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.z())
    }
}
pub trait YZYW<T> {
    fn yzyw(&self) -> PolyVec4<T>;
}
impl<S, T> YZYW<T> for S
where
    S: Y<T> + Z<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.w())
    }
}
pub trait YZZX<T> {
    fn yzzx(&self) -> PolyVec4<T>;
}
impl<S, T> YZZX<T> for S
where
    S: Y<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.x())
    }
}
pub trait YZZY<T> {
    fn yzzy(&self) -> PolyVec4<T>;
}
impl<S, T> YZZY<T> for S
where
    S: Y<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.y())
    }
}
pub trait YZZZ<T> {
    fn yzzz(&self) -> PolyVec4<T>;
}
impl<S, T> YZZZ<T> for S
where
    S: Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.z())
    }
}
pub trait YZZW<T> {
    fn yzzw(&self) -> PolyVec4<T>;
}
impl<S, T> YZZW<T> for S
where
    S: Y<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.w())
    }
}
pub trait YZWX<T> {
    fn yzwx(&self) -> PolyVec4<T>;
}
impl<S, T> YZWX<T> for S
where
    S: Y<T> + Z<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.x())
    }
}
pub trait YZWY<T> {
    fn yzwy(&self) -> PolyVec4<T>;
}
impl<S, T> YZWY<T> for S
where
    S: Y<T> + Z<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.y())
    }
}
pub trait YZWZ<T> {
    fn yzwz(&self) -> PolyVec4<T>;
}
impl<S, T> YZWZ<T> for S
where
    S: Y<T> + Z<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.z())
    }
}
pub trait YZWW<T> {
    fn yzww(&self) -> PolyVec4<T>;
}
impl<S, T> YZWW<T> for S
where
    S: Y<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn yzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.w())
    }
}
pub trait YWXX<T> {
    fn ywxx(&self) -> PolyVec4<T>;
}
impl<S, T> YWXX<T> for S
where
    S: Y<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.x())
    }
}
pub trait YWXY<T> {
    fn ywxy(&self) -> PolyVec4<T>;
}
impl<S, T> YWXY<T> for S
where
    S: Y<T> + W<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.y())
    }
}
pub trait YWXZ<T> {
    fn ywxz(&self) -> PolyVec4<T>;
}
impl<S, T> YWXZ<T> for S
where
    S: Y<T> + W<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.z())
    }
}
pub trait YWXW<T> {
    fn ywxw(&self) -> PolyVec4<T>;
}
impl<S, T> YWXW<T> for S
where
    S: Y<T> + W<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.w())
    }
}
pub trait YWYX<T> {
    fn ywyx(&self) -> PolyVec4<T>;
}
impl<S, T> YWYX<T> for S
where
    S: Y<T> + W<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.x())
    }
}
pub trait YWYY<T> {
    fn ywyy(&self) -> PolyVec4<T>;
}
impl<S, T> YWYY<T> for S
where
    S: Y<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.y())
    }
}
pub trait YWYZ<T> {
    fn ywyz(&self) -> PolyVec4<T>;
}
impl<S, T> YWYZ<T> for S
where
    S: Y<T> + W<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.z())
    }
}
pub trait YWYW<T> {
    fn ywyw(&self) -> PolyVec4<T>;
}
impl<S, T> YWYW<T> for S
where
    S: Y<T> + W<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.w())
    }
}
pub trait YWZX<T> {
    fn ywzx(&self) -> PolyVec4<T>;
}
impl<S, T> YWZX<T> for S
where
    S: Y<T> + W<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.x())
    }
}
pub trait YWZY<T> {
    fn ywzy(&self) -> PolyVec4<T>;
}
impl<S, T> YWZY<T> for S
where
    S: Y<T> + W<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.y())
    }
}
pub trait YWZZ<T> {
    fn ywzz(&self) -> PolyVec4<T>;
}
impl<S, T> YWZZ<T> for S
where
    S: Y<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.z())
    }
}
pub trait YWZW<T> {
    fn ywzw(&self) -> PolyVec4<T>;
}
impl<S, T> YWZW<T> for S
where
    S: Y<T> + W<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.w())
    }
}
pub trait YWWX<T> {
    fn ywwx(&self) -> PolyVec4<T>;
}
impl<S, T> YWWX<T> for S
where
    S: Y<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.x())
    }
}
pub trait YWWY<T> {
    fn ywwy(&self) -> PolyVec4<T>;
}
impl<S, T> YWWY<T> for S
where
    S: Y<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.y())
    }
}
pub trait YWWZ<T> {
    fn ywwz(&self) -> PolyVec4<T>;
}
impl<S, T> YWWZ<T> for S
where
    S: Y<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.z())
    }
}
pub trait YWWW<T> {
    fn ywww(&self) -> PolyVec4<T>;
}
impl<S, T> YWWW<T> for S
where
    S: Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn ywww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.w())
    }
}
pub trait ZXXX<T> {
    fn zxxx(&self) -> PolyVec4<T>;
}
impl<S, T> ZXXX<T> for S
where
    S: Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.x())
    }
}
pub trait ZXXY<T> {
    fn zxxy(&self) -> PolyVec4<T>;
}
impl<S, T> ZXXY<T> for S
where
    S: Z<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.y())
    }
}
pub trait ZXXZ<T> {
    fn zxxz(&self) -> PolyVec4<T>;
}
impl<S, T> ZXXZ<T> for S
where
    S: Z<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.z())
    }
}
pub trait ZXXW<T> {
    fn zxxw(&self) -> PolyVec4<T>;
}
impl<S, T> ZXXW<T> for S
where
    S: Z<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.w())
    }
}
pub trait ZXYX<T> {
    fn zxyx(&self) -> PolyVec4<T>;
}
impl<S, T> ZXYX<T> for S
where
    S: Z<T> + X<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.x())
    }
}
pub trait ZXYY<T> {
    fn zxyy(&self) -> PolyVec4<T>;
}
impl<S, T> ZXYY<T> for S
where
    S: Z<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.y())
    }
}
pub trait ZXYZ<T> {
    fn zxyz(&self) -> PolyVec4<T>;
}
impl<S, T> ZXYZ<T> for S
where
    S: Z<T> + X<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.z())
    }
}
pub trait ZXYW<T> {
    fn zxyw(&self) -> PolyVec4<T>;
}
impl<S, T> ZXYW<T> for S
where
    S: Z<T> + X<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.w())
    }
}
pub trait ZXZX<T> {
    fn zxzx(&self) -> PolyVec4<T>;
}
impl<S, T> ZXZX<T> for S
where
    S: Z<T> + X<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.x())
    }
}
pub trait ZXZY<T> {
    fn zxzy(&self) -> PolyVec4<T>;
}
impl<S, T> ZXZY<T> for S
where
    S: Z<T> + X<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.y())
    }
}
pub trait ZXZZ<T> {
    fn zxzz(&self) -> PolyVec4<T>;
}
impl<S, T> ZXZZ<T> for S
where
    S: Z<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.z())
    }
}
pub trait ZXZW<T> {
    fn zxzw(&self) -> PolyVec4<T>;
}
impl<S, T> ZXZW<T> for S
where
    S: Z<T> + X<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.w())
    }
}
pub trait ZXWX<T> {
    fn zxwx(&self) -> PolyVec4<T>;
}
impl<S, T> ZXWX<T> for S
where
    S: Z<T> + X<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.x())
    }
}
pub trait ZXWY<T> {
    fn zxwy(&self) -> PolyVec4<T>;
}
impl<S, T> ZXWY<T> for S
where
    S: Z<T> + X<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.y())
    }
}
pub trait ZXWZ<T> {
    fn zxwz(&self) -> PolyVec4<T>;
}
impl<S, T> ZXWZ<T> for S
where
    S: Z<T> + X<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.z())
    }
}
pub trait ZXWW<T> {
    fn zxww(&self) -> PolyVec4<T>;
}
impl<S, T> ZXWW<T> for S
where
    S: Z<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.w())
    }
}
pub trait ZYXX<T> {
    fn zyxx(&self) -> PolyVec4<T>;
}
impl<S, T> ZYXX<T> for S
where
    S: Z<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.x())
    }
}
pub trait ZYXY<T> {
    fn zyxy(&self) -> PolyVec4<T>;
}
impl<S, T> ZYXY<T> for S
where
    S: Z<T> + Y<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.y())
    }
}
pub trait ZYXZ<T> {
    fn zyxz(&self) -> PolyVec4<T>;
}
impl<S, T> ZYXZ<T> for S
where
    S: Z<T> + Y<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.z())
    }
}
pub trait ZYXW<T> {
    fn zyxw(&self) -> PolyVec4<T>;
}
impl<S, T> ZYXW<T> for S
where
    S: Z<T> + Y<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.w())
    }
}
pub trait ZYYX<T> {
    fn zyyx(&self) -> PolyVec4<T>;
}
impl<S, T> ZYYX<T> for S
where
    S: Z<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.x())
    }
}
pub trait ZYYY<T> {
    fn zyyy(&self) -> PolyVec4<T>;
}
impl<S, T> ZYYY<T> for S
where
    S: Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.y())
    }
}
pub trait ZYYZ<T> {
    fn zyyz(&self) -> PolyVec4<T>;
}
impl<S, T> ZYYZ<T> for S
where
    S: Z<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.z())
    }
}
pub trait ZYYW<T> {
    fn zyyw(&self) -> PolyVec4<T>;
}
impl<S, T> ZYYW<T> for S
where
    S: Z<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.w())
    }
}
pub trait ZYZX<T> {
    fn zyzx(&self) -> PolyVec4<T>;
}
impl<S, T> ZYZX<T> for S
where
    S: Z<T> + Y<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.x())
    }
}
pub trait ZYZY<T> {
    fn zyzy(&self) -> PolyVec4<T>;
}
impl<S, T> ZYZY<T> for S
where
    S: Z<T> + Y<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.y())
    }
}
pub trait ZYZZ<T> {
    fn zyzz(&self) -> PolyVec4<T>;
}
impl<S, T> ZYZZ<T> for S
where
    S: Z<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.z())
    }
}
pub trait ZYZW<T> {
    fn zyzw(&self) -> PolyVec4<T>;
}
impl<S, T> ZYZW<T> for S
where
    S: Z<T> + Y<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.w())
    }
}
pub trait ZYWX<T> {
    fn zywx(&self) -> PolyVec4<T>;
}
impl<S, T> ZYWX<T> for S
where
    S: Z<T> + Y<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.x())
    }
}
pub trait ZYWY<T> {
    fn zywy(&self) -> PolyVec4<T>;
}
impl<S, T> ZYWY<T> for S
where
    S: Z<T> + Y<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.y())
    }
}
pub trait ZYWZ<T> {
    fn zywz(&self) -> PolyVec4<T>;
}
impl<S, T> ZYWZ<T> for S
where
    S: Z<T> + Y<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.z())
    }
}
pub trait ZYWW<T> {
    fn zyww(&self) -> PolyVec4<T>;
}
impl<S, T> ZYWW<T> for S
where
    S: Z<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.w())
    }
}
pub trait ZZXX<T> {
    fn zzxx(&self) -> PolyVec4<T>;
}
impl<S, T> ZZXX<T> for S
where
    S: Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.x())
    }
}
pub trait ZZXY<T> {
    fn zzxy(&self) -> PolyVec4<T>;
}
impl<S, T> ZZXY<T> for S
where
    S: Z<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.y())
    }
}
pub trait ZZXZ<T> {
    fn zzxz(&self) -> PolyVec4<T>;
}
impl<S, T> ZZXZ<T> for S
where
    S: Z<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.z())
    }
}
pub trait ZZXW<T> {
    fn zzxw(&self) -> PolyVec4<T>;
}
impl<S, T> ZZXW<T> for S
where
    S: Z<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.w())
    }
}
pub trait ZZYX<T> {
    fn zzyx(&self) -> PolyVec4<T>;
}
impl<S, T> ZZYX<T> for S
where
    S: Z<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.x())
    }
}
pub trait ZZYY<T> {
    fn zzyy(&self) -> PolyVec4<T>;
}
impl<S, T> ZZYY<T> for S
where
    S: Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.y())
    }
}
pub trait ZZYZ<T> {
    fn zzyz(&self) -> PolyVec4<T>;
}
impl<S, T> ZZYZ<T> for S
where
    S: Z<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.z())
    }
}
pub trait ZZYW<T> {
    fn zzyw(&self) -> PolyVec4<T>;
}
impl<S, T> ZZYW<T> for S
where
    S: Z<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.w())
    }
}
pub trait ZZZX<T> {
    fn zzzx(&self) -> PolyVec4<T>;
}
impl<S, T> ZZZX<T> for S
where
    S: Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.x())
    }
}
pub trait ZZZY<T> {
    fn zzzy(&self) -> PolyVec4<T>;
}
impl<S, T> ZZZY<T> for S
where
    S: Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.y())
    }
}
pub trait ZZZZ<T> {
    fn zzzz(&self) -> PolyVec4<T>;
}
impl<S, T> ZZZZ<T> for S
where
    S: Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.z())
    }
}
pub trait ZZZW<T> {
    fn zzzw(&self) -> PolyVec4<T>;
}
impl<S, T> ZZZW<T> for S
where
    S: Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.w())
    }
}
pub trait ZZWX<T> {
    fn zzwx(&self) -> PolyVec4<T>;
}
impl<S, T> ZZWX<T> for S
where
    S: Z<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.x())
    }
}
pub trait ZZWY<T> {
    fn zzwy(&self) -> PolyVec4<T>;
}
impl<S, T> ZZWY<T> for S
where
    S: Z<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.y())
    }
}
pub trait ZZWZ<T> {
    fn zzwz(&self) -> PolyVec4<T>;
}
impl<S, T> ZZWZ<T> for S
where
    S: Z<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.z())
    }
}
pub trait ZZWW<T> {
    fn zzww(&self) -> PolyVec4<T>;
}
impl<S, T> ZZWW<T> for S
where
    S: Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.w())
    }
}
pub trait ZWXX<T> {
    fn zwxx(&self) -> PolyVec4<T>;
}
impl<S, T> ZWXX<T> for S
where
    S: Z<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.x())
    }
}
pub trait ZWXY<T> {
    fn zwxy(&self) -> PolyVec4<T>;
}
impl<S, T> ZWXY<T> for S
where
    S: Z<T> + W<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.y())
    }
}
pub trait ZWXZ<T> {
    fn zwxz(&self) -> PolyVec4<T>;
}
impl<S, T> ZWXZ<T> for S
where
    S: Z<T> + W<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.z())
    }
}
pub trait ZWXW<T> {
    fn zwxw(&self) -> PolyVec4<T>;
}
impl<S, T> ZWXW<T> for S
where
    S: Z<T> + W<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.w())
    }
}
pub trait ZWYX<T> {
    fn zwyx(&self) -> PolyVec4<T>;
}
impl<S, T> ZWYX<T> for S
where
    S: Z<T> + W<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.x())
    }
}
pub trait ZWYY<T> {
    fn zwyy(&self) -> PolyVec4<T>;
}
impl<S, T> ZWYY<T> for S
where
    S: Z<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.y())
    }
}
pub trait ZWYZ<T> {
    fn zwyz(&self) -> PolyVec4<T>;
}
impl<S, T> ZWYZ<T> for S
where
    S: Z<T> + W<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.z())
    }
}
pub trait ZWYW<T> {
    fn zwyw(&self) -> PolyVec4<T>;
}
impl<S, T> ZWYW<T> for S
where
    S: Z<T> + W<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.w())
    }
}
pub trait ZWZX<T> {
    fn zwzx(&self) -> PolyVec4<T>;
}
impl<S, T> ZWZX<T> for S
where
    S: Z<T> + W<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.x())
    }
}
pub trait ZWZY<T> {
    fn zwzy(&self) -> PolyVec4<T>;
}
impl<S, T> ZWZY<T> for S
where
    S: Z<T> + W<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.y())
    }
}
pub trait ZWZZ<T> {
    fn zwzz(&self) -> PolyVec4<T>;
}
impl<S, T> ZWZZ<T> for S
where
    S: Z<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.z())
    }
}
pub trait ZWZW<T> {
    fn zwzw(&self) -> PolyVec4<T>;
}
impl<S, T> ZWZW<T> for S
where
    S: Z<T> + W<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.w())
    }
}
pub trait ZWWX<T> {
    fn zwwx(&self) -> PolyVec4<T>;
}
impl<S, T> ZWWX<T> for S
where
    S: Z<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.x())
    }
}
pub trait ZWWY<T> {
    fn zwwy(&self) -> PolyVec4<T>;
}
impl<S, T> ZWWY<T> for S
where
    S: Z<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.y())
    }
}
pub trait ZWWZ<T> {
    fn zwwz(&self) -> PolyVec4<T>;
}
impl<S, T> ZWWZ<T> for S
where
    S: Z<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.z())
    }
}
pub trait ZWWW<T> {
    fn zwww(&self) -> PolyVec4<T>;
}
impl<S, T> ZWWW<T> for S
where
    S: Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn zwww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.w())
    }
}
pub trait WXXX<T> {
    fn wxxx(&self) -> PolyVec4<T>;
}
impl<S, T> WXXX<T> for S
where
    S: W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.x())
    }
}
pub trait WXXY<T> {
    fn wxxy(&self) -> PolyVec4<T>;
}
impl<S, T> WXXY<T> for S
where
    S: W<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.y())
    }
}
pub trait WXXZ<T> {
    fn wxxz(&self) -> PolyVec4<T>;
}
impl<S, T> WXXZ<T> for S
where
    S: W<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.z())
    }
}
pub trait WXXW<T> {
    fn wxxw(&self) -> PolyVec4<T>;
}
impl<S, T> WXXW<T> for S
where
    S: W<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.w())
    }
}
pub trait WXYX<T> {
    fn wxyx(&self) -> PolyVec4<T>;
}
impl<S, T> WXYX<T> for S
where
    S: W<T> + X<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.x())
    }
}
pub trait WXYY<T> {
    fn wxyy(&self) -> PolyVec4<T>;
}
impl<S, T> WXYY<T> for S
where
    S: W<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.y())
    }
}
pub trait WXYZ<T> {
    fn wxyz(&self) -> PolyVec4<T>;
}
impl<S, T> WXYZ<T> for S
where
    S: W<T> + X<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.z())
    }
}
pub trait WXYW<T> {
    fn wxyw(&self) -> PolyVec4<T>;
}
impl<S, T> WXYW<T> for S
where
    S: W<T> + X<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.w())
    }
}
pub trait WXZX<T> {
    fn wxzx(&self) -> PolyVec4<T>;
}
impl<S, T> WXZX<T> for S
where
    S: W<T> + X<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.x())
    }
}
pub trait WXZY<T> {
    fn wxzy(&self) -> PolyVec4<T>;
}
impl<S, T> WXZY<T> for S
where
    S: W<T> + X<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.y())
    }
}
pub trait WXZZ<T> {
    fn wxzz(&self) -> PolyVec4<T>;
}
impl<S, T> WXZZ<T> for S
where
    S: W<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.z())
    }
}
pub trait WXZW<T> {
    fn wxzw(&self) -> PolyVec4<T>;
}
impl<S, T> WXZW<T> for S
where
    S: W<T> + X<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.w())
    }
}
pub trait WXWX<T> {
    fn wxwx(&self) -> PolyVec4<T>;
}
impl<S, T> WXWX<T> for S
where
    S: W<T> + X<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.x())
    }
}
pub trait WXWY<T> {
    fn wxwy(&self) -> PolyVec4<T>;
}
impl<S, T> WXWY<T> for S
where
    S: W<T> + X<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.y())
    }
}
pub trait WXWZ<T> {
    fn wxwz(&self) -> PolyVec4<T>;
}
impl<S, T> WXWZ<T> for S
where
    S: W<T> + X<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.z())
    }
}
pub trait WXWW<T> {
    fn wxww(&self) -> PolyVec4<T>;
}
impl<S, T> WXWW<T> for S
where
    S: W<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.w())
    }
}
pub trait WYXX<T> {
    fn wyxx(&self) -> PolyVec4<T>;
}
impl<S, T> WYXX<T> for S
where
    S: W<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.x())
    }
}
pub trait WYXY<T> {
    fn wyxy(&self) -> PolyVec4<T>;
}
impl<S, T> WYXY<T> for S
where
    S: W<T> + Y<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.y())
    }
}
pub trait WYXZ<T> {
    fn wyxz(&self) -> PolyVec4<T>;
}
impl<S, T> WYXZ<T> for S
where
    S: W<T> + Y<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.z())
    }
}
pub trait WYXW<T> {
    fn wyxw(&self) -> PolyVec4<T>;
}
impl<S, T> WYXW<T> for S
where
    S: W<T> + Y<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.w())
    }
}
pub trait WYYX<T> {
    fn wyyx(&self) -> PolyVec4<T>;
}
impl<S, T> WYYX<T> for S
where
    S: W<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.x())
    }
}
pub trait WYYY<T> {
    fn wyyy(&self) -> PolyVec4<T>;
}
impl<S, T> WYYY<T> for S
where
    S: W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.y())
    }
}
pub trait WYYZ<T> {
    fn wyyz(&self) -> PolyVec4<T>;
}
impl<S, T> WYYZ<T> for S
where
    S: W<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.z())
    }
}
pub trait WYYW<T> {
    fn wyyw(&self) -> PolyVec4<T>;
}
impl<S, T> WYYW<T> for S
where
    S: W<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.w())
    }
}
pub trait WYZX<T> {
    fn wyzx(&self) -> PolyVec4<T>;
}
impl<S, T> WYZX<T> for S
where
    S: W<T> + Y<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.x())
    }
}
pub trait WYZY<T> {
    fn wyzy(&self) -> PolyVec4<T>;
}
impl<S, T> WYZY<T> for S
where
    S: W<T> + Y<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.y())
    }
}
pub trait WYZZ<T> {
    fn wyzz(&self) -> PolyVec4<T>;
}
impl<S, T> WYZZ<T> for S
where
    S: W<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.z())
    }
}
pub trait WYZW<T> {
    fn wyzw(&self) -> PolyVec4<T>;
}
impl<S, T> WYZW<T> for S
where
    S: W<T> + Y<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.w())
    }
}
pub trait WYWX<T> {
    fn wywx(&self) -> PolyVec4<T>;
}
impl<S, T> WYWX<T> for S
where
    S: W<T> + Y<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.x())
    }
}
pub trait WYWY<T> {
    fn wywy(&self) -> PolyVec4<T>;
}
impl<S, T> WYWY<T> for S
where
    S: W<T> + Y<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.y())
    }
}
pub trait WYWZ<T> {
    fn wywz(&self) -> PolyVec4<T>;
}
impl<S, T> WYWZ<T> for S
where
    S: W<T> + Y<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.z())
    }
}
pub trait WYWW<T> {
    fn wyww(&self) -> PolyVec4<T>;
}
impl<S, T> WYWW<T> for S
where
    S: W<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.w())
    }
}
pub trait WZXX<T> {
    fn wzxx(&self) -> PolyVec4<T>;
}
impl<S, T> WZXX<T> for S
where
    S: W<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.x())
    }
}
pub trait WZXY<T> {
    fn wzxy(&self) -> PolyVec4<T>;
}
impl<S, T> WZXY<T> for S
where
    S: W<T> + Z<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.y())
    }
}
pub trait WZXZ<T> {
    fn wzxz(&self) -> PolyVec4<T>;
}
impl<S, T> WZXZ<T> for S
where
    S: W<T> + Z<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.z())
    }
}
pub trait WZXW<T> {
    fn wzxw(&self) -> PolyVec4<T>;
}
impl<S, T> WZXW<T> for S
where
    S: W<T> + Z<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.w())
    }
}
pub trait WZYX<T> {
    fn wzyx(&self) -> PolyVec4<T>;
}
impl<S, T> WZYX<T> for S
where
    S: W<T> + Z<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.x())
    }
}
pub trait WZYY<T> {
    fn wzyy(&self) -> PolyVec4<T>;
}
impl<S, T> WZYY<T> for S
where
    S: W<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.y())
    }
}
pub trait WZYZ<T> {
    fn wzyz(&self) -> PolyVec4<T>;
}
impl<S, T> WZYZ<T> for S
where
    S: W<T> + Z<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.z())
    }
}
pub trait WZYW<T> {
    fn wzyw(&self) -> PolyVec4<T>;
}
impl<S, T> WZYW<T> for S
where
    S: W<T> + Z<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.w())
    }
}
pub trait WZZX<T> {
    fn wzzx(&self) -> PolyVec4<T>;
}
impl<S, T> WZZX<T> for S
where
    S: W<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.x())
    }
}
pub trait WZZY<T> {
    fn wzzy(&self) -> PolyVec4<T>;
}
impl<S, T> WZZY<T> for S
where
    S: W<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.y())
    }
}
pub trait WZZZ<T> {
    fn wzzz(&self) -> PolyVec4<T>;
}
impl<S, T> WZZZ<T> for S
where
    S: W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.z())
    }
}
pub trait WZZW<T> {
    fn wzzw(&self) -> PolyVec4<T>;
}
impl<S, T> WZZW<T> for S
where
    S: W<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.w())
    }
}
pub trait WZWX<T> {
    fn wzwx(&self) -> PolyVec4<T>;
}
impl<S, T> WZWX<T> for S
where
    S: W<T> + Z<T> + W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.x())
    }
}
pub trait WZWY<T> {
    fn wzwy(&self) -> PolyVec4<T>;
}
impl<S, T> WZWY<T> for S
where
    S: W<T> + Z<T> + W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.y())
    }
}
pub trait WZWZ<T> {
    fn wzwz(&self) -> PolyVec4<T>;
}
impl<S, T> WZWZ<T> for S
where
    S: W<T> + Z<T> + W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.z())
    }
}
pub trait WZWW<T> {
    fn wzww(&self) -> PolyVec4<T>;
}
impl<S, T> WZWW<T> for S
where
    S: W<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.w())
    }
}
pub trait WWXX<T> {
    fn wwxx(&self) -> PolyVec4<T>;
}
impl<S, T> WWXX<T> for S
where
    S: W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.x())
    }
}
pub trait WWXY<T> {
    fn wwxy(&self) -> PolyVec4<T>;
}
impl<S, T> WWXY<T> for S
where
    S: W<T> + X<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.y())
    }
}
pub trait WWXZ<T> {
    fn wwxz(&self) -> PolyVec4<T>;
}
impl<S, T> WWXZ<T> for S
where
    S: W<T> + X<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.z())
    }
}
pub trait WWXW<T> {
    fn wwxw(&self) -> PolyVec4<T>;
}
impl<S, T> WWXW<T> for S
where
    S: W<T> + X<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.w())
    }
}
pub trait WWYX<T> {
    fn wwyx(&self) -> PolyVec4<T>;
}
impl<S, T> WWYX<T> for S
where
    S: W<T> + Y<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.x())
    }
}
pub trait WWYY<T> {
    fn wwyy(&self) -> PolyVec4<T>;
}
impl<S, T> WWYY<T> for S
where
    S: W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.y())
    }
}
pub trait WWYZ<T> {
    fn wwyz(&self) -> PolyVec4<T>;
}
impl<S, T> WWYZ<T> for S
where
    S: W<T> + Y<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.z())
    }
}
pub trait WWYW<T> {
    fn wwyw(&self) -> PolyVec4<T>;
}
impl<S, T> WWYW<T> for S
where
    S: W<T> + Y<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.w())
    }
}
pub trait WWZX<T> {
    fn wwzx(&self) -> PolyVec4<T>;
}
impl<S, T> WWZX<T> for S
where
    S: W<T> + Z<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.x())
    }
}
pub trait WWZY<T> {
    fn wwzy(&self) -> PolyVec4<T>;
}
impl<S, T> WWZY<T> for S
where
    S: W<T> + Z<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.y())
    }
}
pub trait WWZZ<T> {
    fn wwzz(&self) -> PolyVec4<T>;
}
impl<S, T> WWZZ<T> for S
where
    S: W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.z())
    }
}
pub trait WWZW<T> {
    fn wwzw(&self) -> PolyVec4<T>;
}
impl<S, T> WWZW<T> for S
where
    S: W<T> + Z<T> + W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.w())
    }
}
pub trait WWWX<T> {
    fn wwwx(&self) -> PolyVec4<T>;
}
impl<S, T> WWWX<T> for S
where
    S: W<T> + X<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.x())
    }
}
pub trait WWWY<T> {
    fn wwwy(&self) -> PolyVec4<T>;
}
impl<S, T> WWWY<T> for S
where
    S: W<T> + Y<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.y())
    }
}
pub trait WWWZ<T> {
    fn wwwz(&self) -> PolyVec4<T>;
}
impl<S, T> WWWZ<T> for S
where
    S: W<T> + Z<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.z())
    }
}
pub trait WWWW<T> {
    fn wwww(&self) -> PolyVec4<T>;
}
impl<S, T> WWWW<T> for S
where
    S: W<T>,
    T: Copy,
{
    #[inline(always)]
    fn wwww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.w())
    }
}
