// WARNING: This file was generated automatically using gen_swizzle.rs. Don't modify
    
use crate::vec::{X, Y, Z, W, PolyVec2, PolyVec3, PolyVec4};

// ---------- 2-Component Swizzle ----------


pub trait SwizzleXX<T> {
    fn xx(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleXX<T> for S where
S: X<T>,
T: Copy {
    #[inline(always)]
    fn xx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.x())
    }
}
pub trait SwizzleXY<T> {
    fn xy(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleXY<T> for S where
S: X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.y())
    }
}
pub trait SwizzleXZ<T> {
    fn xz(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleXZ<T> for S where
S: X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.z())
    }
}
pub trait SwizzleXW<T> {
    fn xw(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleXW<T> for S where
S: X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xw(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.x(), *self.w())
    }
}
pub trait SwizzleYX<T> {
    fn yx(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleYX<T> for S where
S: Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.x())
    }
}
pub trait SwizzleYY<T> {
    fn yy(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleYY<T> for S where
S: Y<T>,
T: Copy {
    #[inline(always)]
    fn yy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.y())
    }
}
pub trait SwizzleYZ<T> {
    fn yz(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleYZ<T> for S where
S: Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.z())
    }
}
pub trait SwizzleYW<T> {
    fn yw(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleYW<T> for S where
S: Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yw(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.y(), *self.w())
    }
}
pub trait SwizzleZX<T> {
    fn zx(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleZX<T> for S where
S: Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.x())
    }
}
pub trait SwizzleZY<T> {
    fn zy(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleZY<T> for S where
S: Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.y())
    }
}
pub trait SwizzleZZ<T> {
    fn zz(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleZZ<T> for S where
S: Z<T>,
T: Copy {
    #[inline(always)]
    fn zz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.z())
    }
}
pub trait SwizzleZW<T> {
    fn zw(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleZW<T> for S where
S: Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zw(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.z(), *self.w())
    }
}
pub trait SwizzleWX<T> {
    fn wx(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleWX<T> for S where
S: W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wx(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.x())
    }
}
pub trait SwizzleWY<T> {
    fn wy(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleWY<T> for S where
S: W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wy(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.y())
    }
}
pub trait SwizzleWZ<T> {
    fn wz(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleWZ<T> for S where
S: W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wz(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.z())
    }
}
pub trait SwizzleWW<T> {
    fn ww(&self) -> PolyVec2<T>;
}
impl<S, T> SwizzleWW<T> for S where
S: W<T>,
T: Copy {
    #[inline(always)]
    fn ww(&self) -> PolyVec2<T> {
        PolyVec2::new(*self.w(), *self.w())
    }
}

// ---------- 3-Component Swizzle ----------


pub trait SwizzleXXX<T> {
    fn xxx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXXX<T> for S where
S: X<T>,
T: Copy {
    #[inline(always)]
    fn xxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.x())
    }
}
pub trait SwizzleXXY<T> {
    fn xxy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXXY<T> for S where
S: X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.y())
    }
}
pub trait SwizzleXXZ<T> {
    fn xxz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXXZ<T> for S where
S: X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.z())
    }
}
pub trait SwizzleXXW<T> {
    fn xxw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXXW<T> for S where
S: X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.x(), *self.w())
    }
}
pub trait SwizzleXYX<T> {
    fn xyx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXYX<T> for S where
S: X<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.x())
    }
}
pub trait SwizzleXYY<T> {
    fn xyy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXYY<T> for S where
S: X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.y())
    }
}
pub trait SwizzleXYZ<T> {
    fn xyz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXYZ<T> for S where
S: X<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.z())
    }
}
pub trait SwizzleXYW<T> {
    fn xyw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXYW<T> for S where
S: X<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.y(), *self.w())
    }
}
pub trait SwizzleXZX<T> {
    fn xzx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXZX<T> for S where
S: X<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.x())
    }
}
pub trait SwizzleXZY<T> {
    fn xzy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXZY<T> for S where
S: X<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.y())
    }
}
pub trait SwizzleXZZ<T> {
    fn xzz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXZZ<T> for S where
S: X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.z())
    }
}
pub trait SwizzleXZW<T> {
    fn xzw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXZW<T> for S where
S: X<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.z(), *self.w())
    }
}
pub trait SwizzleXWX<T> {
    fn xwx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXWX<T> for S where
S: X<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xwx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.x())
    }
}
pub trait SwizzleXWY<T> {
    fn xwy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXWY<T> for S where
S: X<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xwy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.y())
    }
}
pub trait SwizzleXWZ<T> {
    fn xwz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXWZ<T> for S where
S: X<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xwz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.z())
    }
}
pub trait SwizzleXWW<T> {
    fn xww(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleXWW<T> for S where
S: X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xww(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.x(), *self.w(), *self.w())
    }
}
pub trait SwizzleYXX<T> {
    fn yxx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYXX<T> for S where
S: Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.x())
    }
}
pub trait SwizzleYXY<T> {
    fn yxy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYXY<T> for S where
S: Y<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.y())
    }
}
pub trait SwizzleYXZ<T> {
    fn yxz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYXZ<T> for S where
S: Y<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.z())
    }
}
pub trait SwizzleYXW<T> {
    fn yxw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYXW<T> for S where
S: Y<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.x(), *self.w())
    }
}
pub trait SwizzleYYX<T> {
    fn yyx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYYX<T> for S where
S: Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.x())
    }
}
pub trait SwizzleYYY<T> {
    fn yyy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYYY<T> for S where
S: Y<T>,
T: Copy {
    #[inline(always)]
    fn yyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.y())
    }
}
pub trait SwizzleYYZ<T> {
    fn yyz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYYZ<T> for S where
S: Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.z())
    }
}
pub trait SwizzleYYW<T> {
    fn yyw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYYW<T> for S where
S: Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.y(), *self.w())
    }
}
pub trait SwizzleYZX<T> {
    fn yzx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYZX<T> for S where
S: Y<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.x())
    }
}
pub trait SwizzleYZY<T> {
    fn yzy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYZY<T> for S where
S: Y<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.y())
    }
}
pub trait SwizzleYZZ<T> {
    fn yzz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYZZ<T> for S where
S: Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.z())
    }
}
pub trait SwizzleYZW<T> {
    fn yzw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYZW<T> for S where
S: Y<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.z(), *self.w())
    }
}
pub trait SwizzleYWX<T> {
    fn ywx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYWX<T> for S where
S: Y<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn ywx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.x())
    }
}
pub trait SwizzleYWY<T> {
    fn ywy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYWY<T> for S where
S: Y<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn ywy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.y())
    }
}
pub trait SwizzleYWZ<T> {
    fn ywz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYWZ<T> for S where
S: Y<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn ywz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.z())
    }
}
pub trait SwizzleYWW<T> {
    fn yww(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleYWW<T> for S where
S: Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yww(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.y(), *self.w(), *self.w())
    }
}
pub trait SwizzleZXX<T> {
    fn zxx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZXX<T> for S where
S: Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.x())
    }
}
pub trait SwizzleZXY<T> {
    fn zxy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZXY<T> for S where
S: Z<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.y())
    }
}
pub trait SwizzleZXZ<T> {
    fn zxz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZXZ<T> for S where
S: Z<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.z())
    }
}
pub trait SwizzleZXW<T> {
    fn zxw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZXW<T> for S where
S: Z<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.x(), *self.w())
    }
}
pub trait SwizzleZYX<T> {
    fn zyx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZYX<T> for S where
S: Z<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.x())
    }
}
pub trait SwizzleZYY<T> {
    fn zyy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZYY<T> for S where
S: Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.y())
    }
}
pub trait SwizzleZYZ<T> {
    fn zyz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZYZ<T> for S where
S: Z<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.z())
    }
}
pub trait SwizzleZYW<T> {
    fn zyw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZYW<T> for S where
S: Z<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.y(), *self.w())
    }
}
pub trait SwizzleZZX<T> {
    fn zzx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZZX<T> for S where
S: Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.x())
    }
}
pub trait SwizzleZZY<T> {
    fn zzy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZZY<T> for S where
S: Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.y())
    }
}
pub trait SwizzleZZZ<T> {
    fn zzz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZZZ<T> for S where
S: Z<T>,
T: Copy {
    #[inline(always)]
    fn zzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.z())
    }
}
pub trait SwizzleZZW<T> {
    fn zzw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZZW<T> for S where
S: Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.z(), *self.w())
    }
}
pub trait SwizzleZWX<T> {
    fn zwx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZWX<T> for S where
S: Z<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zwx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.x())
    }
}
pub trait SwizzleZWY<T> {
    fn zwy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZWY<T> for S where
S: Z<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zwy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.y())
    }
}
pub trait SwizzleZWZ<T> {
    fn zwz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZWZ<T> for S where
S: Z<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zwz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.z())
    }
}
pub trait SwizzleZWW<T> {
    fn zww(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleZWW<T> for S where
S: Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zww(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.z(), *self.w(), *self.w())
    }
}
pub trait SwizzleWXX<T> {
    fn wxx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWXX<T> for S where
S: W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wxx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.x())
    }
}
pub trait SwizzleWXY<T> {
    fn wxy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWXY<T> for S where
S: W<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wxy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.y())
    }
}
pub trait SwizzleWXZ<T> {
    fn wxz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWXZ<T> for S where
S: W<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wxz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.z())
    }
}
pub trait SwizzleWXW<T> {
    fn wxw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWXW<T> for S where
S: W<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wxw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.x(), *self.w())
    }
}
pub trait SwizzleWYX<T> {
    fn wyx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWYX<T> for S where
S: W<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wyx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.x())
    }
}
pub trait SwizzleWYY<T> {
    fn wyy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWYY<T> for S where
S: W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wyy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.y())
    }
}
pub trait SwizzleWYZ<T> {
    fn wyz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWYZ<T> for S where
S: W<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wyz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.z())
    }
}
pub trait SwizzleWYW<T> {
    fn wyw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWYW<T> for S where
S: W<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wyw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.y(), *self.w())
    }
}
pub trait SwizzleWZX<T> {
    fn wzx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWZX<T> for S where
S: W<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wzx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.x())
    }
}
pub trait SwizzleWZY<T> {
    fn wzy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWZY<T> for S where
S: W<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wzy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.y())
    }
}
pub trait SwizzleWZZ<T> {
    fn wzz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWZZ<T> for S where
S: W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wzz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.z())
    }
}
pub trait SwizzleWZW<T> {
    fn wzw(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWZW<T> for S where
S: W<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wzw(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.z(), *self.w())
    }
}
pub trait SwizzleWWX<T> {
    fn wwx(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWWX<T> for S where
S: W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wwx(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.x())
    }
}
pub trait SwizzleWWY<T> {
    fn wwy(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWWY<T> for S where
S: W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wwy(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.y())
    }
}
pub trait SwizzleWWZ<T> {
    fn wwz(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWWZ<T> for S where
S: W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wwz(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.z())
    }
}
pub trait SwizzleWWW<T> {
    fn www(&self) -> PolyVec3<T>;
}
impl<S, T> SwizzleWWW<T> for S where
S: W<T>,
T: Copy {
    #[inline(always)]
    fn www(&self) -> PolyVec3<T> {
        PolyVec3::new(*self.w(), *self.w(), *self.w())
    }
}

// ---------- 4-Component Swizzle ----------


pub trait SwizzleXXXX<T> {
    fn xxxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXXX<T> for S where
S: X<T>,
T: Copy {
    #[inline(always)]
    fn xxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.x())
    }
}
pub trait SwizzleXXXY<T> {
    fn xxxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXXY<T> for S where
S: X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.y())
    }
}
pub trait SwizzleXXXZ<T> {
    fn xxxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXXZ<T> for S where
S: X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.z())
    }
}
pub trait SwizzleXXXW<T> {
    fn xxxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXXW<T> for S where
S: X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.x(), *self.w())
    }
}
pub trait SwizzleXXYX<T> {
    fn xxyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXYX<T> for S where
S: X<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.x())
    }
}
pub trait SwizzleXXYY<T> {
    fn xxyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXYY<T> for S where
S: X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.y())
    }
}
pub trait SwizzleXXYZ<T> {
    fn xxyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXYZ<T> for S where
S: X<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.z())
    }
}
pub trait SwizzleXXYW<T> {
    fn xxyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXYW<T> for S where
S: X<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.y(), *self.w())
    }
}
pub trait SwizzleXXZX<T> {
    fn xxzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXZX<T> for S where
S: X<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.x())
    }
}
pub trait SwizzleXXZY<T> {
    fn xxzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXZY<T> for S where
S: X<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.y())
    }
}
pub trait SwizzleXXZZ<T> {
    fn xxzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXZZ<T> for S where
S: X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.z())
    }
}
pub trait SwizzleXXZW<T> {
    fn xxzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXZW<T> for S where
S: X<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.z(), *self.w())
    }
}
pub trait SwizzleXXWX<T> {
    fn xxwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXWX<T> for S where
S: X<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.x())
    }
}
pub trait SwizzleXXWY<T> {
    fn xxwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXWY<T> for S where
S: X<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.y())
    }
}
pub trait SwizzleXXWZ<T> {
    fn xxwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXWZ<T> for S where
S: X<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.z())
    }
}
pub trait SwizzleXXWW<T> {
    fn xxww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXXWW<T> for S where
S: X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.x(), *self.w(), *self.w())
    }
}
pub trait SwizzleXYXX<T> {
    fn xyxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYXX<T> for S where
S: X<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.x())
    }
}
pub trait SwizzleXYXY<T> {
    fn xyxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYXY<T> for S where
S: X<T> + Y<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.y())
    }
}
pub trait SwizzleXYXZ<T> {
    fn xyxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYXZ<T> for S where
S: X<T> + Y<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.z())
    }
}
pub trait SwizzleXYXW<T> {
    fn xyxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYXW<T> for S where
S: X<T> + Y<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.x(), *self.w())
    }
}
pub trait SwizzleXYYX<T> {
    fn xyyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYYX<T> for S where
S: X<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.x())
    }
}
pub trait SwizzleXYYY<T> {
    fn xyyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYYY<T> for S where
S: X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.y())
    }
}
pub trait SwizzleXYYZ<T> {
    fn xyyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYYZ<T> for S where
S: X<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.z())
    }
}
pub trait SwizzleXYYW<T> {
    fn xyyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYYW<T> for S where
S: X<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.y(), *self.w())
    }
}
pub trait SwizzleXYZX<T> {
    fn xyzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYZX<T> for S where
S: X<T> + Y<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.x())
    }
}
pub trait SwizzleXYZY<T> {
    fn xyzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYZY<T> for S where
S: X<T> + Y<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.y())
    }
}
pub trait SwizzleXYZZ<T> {
    fn xyzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYZZ<T> for S where
S: X<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.z())
    }
}
pub trait SwizzleXYZW<T> {
    fn xyzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYZW<T> for S where
S: X<T> + Y<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.z(), *self.w())
    }
}
pub trait SwizzleXYWX<T> {
    fn xywx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYWX<T> for S where
S: X<T> + Y<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.x())
    }
}
pub trait SwizzleXYWY<T> {
    fn xywy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYWY<T> for S where
S: X<T> + Y<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.y())
    }
}
pub trait SwizzleXYWZ<T> {
    fn xywz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYWZ<T> for S where
S: X<T> + Y<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.z())
    }
}
pub trait SwizzleXYWW<T> {
    fn xyww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXYWW<T> for S where
S: X<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.y(), *self.w(), *self.w())
    }
}
pub trait SwizzleXZXX<T> {
    fn xzxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZXX<T> for S where
S: X<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.x())
    }
}
pub trait SwizzleXZXY<T> {
    fn xzxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZXY<T> for S where
S: X<T> + Z<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.y())
    }
}
pub trait SwizzleXZXZ<T> {
    fn xzxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZXZ<T> for S where
S: X<T> + Z<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.z())
    }
}
pub trait SwizzleXZXW<T> {
    fn xzxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZXW<T> for S where
S: X<T> + Z<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.x(), *self.w())
    }
}
pub trait SwizzleXZYX<T> {
    fn xzyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZYX<T> for S where
S: X<T> + Z<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.x())
    }
}
pub trait SwizzleXZYY<T> {
    fn xzyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZYY<T> for S where
S: X<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.y())
    }
}
pub trait SwizzleXZYZ<T> {
    fn xzyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZYZ<T> for S where
S: X<T> + Z<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.z())
    }
}
pub trait SwizzleXZYW<T> {
    fn xzyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZYW<T> for S where
S: X<T> + Z<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.y(), *self.w())
    }
}
pub trait SwizzleXZZX<T> {
    fn xzzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZZX<T> for S where
S: X<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.x())
    }
}
pub trait SwizzleXZZY<T> {
    fn xzzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZZY<T> for S where
S: X<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.y())
    }
}
pub trait SwizzleXZZZ<T> {
    fn xzzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZZZ<T> for S where
S: X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.z())
    }
}
pub trait SwizzleXZZW<T> {
    fn xzzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZZW<T> for S where
S: X<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.z(), *self.w())
    }
}
pub trait SwizzleXZWX<T> {
    fn xzwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZWX<T> for S where
S: X<T> + Z<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.x())
    }
}
pub trait SwizzleXZWY<T> {
    fn xzwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZWY<T> for S where
S: X<T> + Z<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.y())
    }
}
pub trait SwizzleXZWZ<T> {
    fn xzwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZWZ<T> for S where
S: X<T> + Z<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.z())
    }
}
pub trait SwizzleXZWW<T> {
    fn xzww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXZWW<T> for S where
S: X<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.z(), *self.w(), *self.w())
    }
}
pub trait SwizzleXWXX<T> {
    fn xwxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWXX<T> for S where
S: X<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xwxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.x())
    }
}
pub trait SwizzleXWXY<T> {
    fn xwxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWXY<T> for S where
S: X<T> + W<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xwxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.y())
    }
}
pub trait SwizzleXWXZ<T> {
    fn xwxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWXZ<T> for S where
S: X<T> + W<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xwxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.z())
    }
}
pub trait SwizzleXWXW<T> {
    fn xwxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWXW<T> for S where
S: X<T> + W<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xwxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.x(), *self.w())
    }
}
pub trait SwizzleXWYX<T> {
    fn xwyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWYX<T> for S where
S: X<T> + W<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xwyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.x())
    }
}
pub trait SwizzleXWYY<T> {
    fn xwyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWYY<T> for S where
S: X<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xwyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.y())
    }
}
pub trait SwizzleXWYZ<T> {
    fn xwyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWYZ<T> for S where
S: X<T> + W<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xwyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.z())
    }
}
pub trait SwizzleXWYW<T> {
    fn xwyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWYW<T> for S where
S: X<T> + W<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xwyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.y(), *self.w())
    }
}
pub trait SwizzleXWZX<T> {
    fn xwzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWZX<T> for S where
S: X<T> + W<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xwzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.x())
    }
}
pub trait SwizzleXWZY<T> {
    fn xwzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWZY<T> for S where
S: X<T> + W<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xwzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.y())
    }
}
pub trait SwizzleXWZZ<T> {
    fn xwzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWZZ<T> for S where
S: X<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xwzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.z())
    }
}
pub trait SwizzleXWZW<T> {
    fn xwzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWZW<T> for S where
S: X<T> + W<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xwzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.z(), *self.w())
    }
}
pub trait SwizzleXWWX<T> {
    fn xwwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWWX<T> for S where
S: X<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn xwwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.x())
    }
}
pub trait SwizzleXWWY<T> {
    fn xwwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWWY<T> for S where
S: X<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn xwwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.y())
    }
}
pub trait SwizzleXWWZ<T> {
    fn xwwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWWZ<T> for S where
S: X<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn xwwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.z())
    }
}
pub trait SwizzleXWWW<T> {
    fn xwww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleXWWW<T> for S where
S: X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn xwww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.x(), *self.w(), *self.w(), *self.w())
    }
}
pub trait SwizzleYXXX<T> {
    fn yxxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXXX<T> for S where
S: Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.x())
    }
}
pub trait SwizzleYXXY<T> {
    fn yxxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXXY<T> for S where
S: Y<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.y())
    }
}
pub trait SwizzleYXXZ<T> {
    fn yxxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXXZ<T> for S where
S: Y<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.z())
    }
}
pub trait SwizzleYXXW<T> {
    fn yxxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXXW<T> for S where
S: Y<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.x(), *self.w())
    }
}
pub trait SwizzleYXYX<T> {
    fn yxyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXYX<T> for S where
S: Y<T> + X<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.x())
    }
}
pub trait SwizzleYXYY<T> {
    fn yxyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXYY<T> for S where
S: Y<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.y())
    }
}
pub trait SwizzleYXYZ<T> {
    fn yxyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXYZ<T> for S where
S: Y<T> + X<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.z())
    }
}
pub trait SwizzleYXYW<T> {
    fn yxyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXYW<T> for S where
S: Y<T> + X<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.y(), *self.w())
    }
}
pub trait SwizzleYXZX<T> {
    fn yxzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXZX<T> for S where
S: Y<T> + X<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.x())
    }
}
pub trait SwizzleYXZY<T> {
    fn yxzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXZY<T> for S where
S: Y<T> + X<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.y())
    }
}
pub trait SwizzleYXZZ<T> {
    fn yxzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXZZ<T> for S where
S: Y<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.z())
    }
}
pub trait SwizzleYXZW<T> {
    fn yxzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXZW<T> for S where
S: Y<T> + X<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.z(), *self.w())
    }
}
pub trait SwizzleYXWX<T> {
    fn yxwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXWX<T> for S where
S: Y<T> + X<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.x())
    }
}
pub trait SwizzleYXWY<T> {
    fn yxwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXWY<T> for S where
S: Y<T> + X<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.y())
    }
}
pub trait SwizzleYXWZ<T> {
    fn yxwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXWZ<T> for S where
S: Y<T> + X<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.z())
    }
}
pub trait SwizzleYXWW<T> {
    fn yxww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYXWW<T> for S where
S: Y<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.x(), *self.w(), *self.w())
    }
}
pub trait SwizzleYYXX<T> {
    fn yyxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYXX<T> for S where
S: Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.x())
    }
}
pub trait SwizzleYYXY<T> {
    fn yyxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYXY<T> for S where
S: Y<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.y())
    }
}
pub trait SwizzleYYXZ<T> {
    fn yyxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYXZ<T> for S where
S: Y<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.z())
    }
}
pub trait SwizzleYYXW<T> {
    fn yyxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYXW<T> for S where
S: Y<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.x(), *self.w())
    }
}
pub trait SwizzleYYYX<T> {
    fn yyyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYYX<T> for S where
S: Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.x())
    }
}
pub trait SwizzleYYYY<T> {
    fn yyyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYYY<T> for S where
S: Y<T>,
T: Copy {
    #[inline(always)]
    fn yyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.y())
    }
}
pub trait SwizzleYYYZ<T> {
    fn yyyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYYZ<T> for S where
S: Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.z())
    }
}
pub trait SwizzleYYYW<T> {
    fn yyyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYYW<T> for S where
S: Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.y(), *self.w())
    }
}
pub trait SwizzleYYZX<T> {
    fn yyzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYZX<T> for S where
S: Y<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.x())
    }
}
pub trait SwizzleYYZY<T> {
    fn yyzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYZY<T> for S where
S: Y<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.y())
    }
}
pub trait SwizzleYYZZ<T> {
    fn yyzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYZZ<T> for S where
S: Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.z())
    }
}
pub trait SwizzleYYZW<T> {
    fn yyzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYZW<T> for S where
S: Y<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.z(), *self.w())
    }
}
pub trait SwizzleYYWX<T> {
    fn yywx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYWX<T> for S where
S: Y<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.x())
    }
}
pub trait SwizzleYYWY<T> {
    fn yywy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYWY<T> for S where
S: Y<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.y())
    }
}
pub trait SwizzleYYWZ<T> {
    fn yywz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYWZ<T> for S where
S: Y<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.z())
    }
}
pub trait SwizzleYYWW<T> {
    fn yyww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYYWW<T> for S where
S: Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.y(), *self.w(), *self.w())
    }
}
pub trait SwizzleYZXX<T> {
    fn yzxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZXX<T> for S where
S: Y<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.x())
    }
}
pub trait SwizzleYZXY<T> {
    fn yzxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZXY<T> for S where
S: Y<T> + Z<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.y())
    }
}
pub trait SwizzleYZXZ<T> {
    fn yzxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZXZ<T> for S where
S: Y<T> + Z<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.z())
    }
}
pub trait SwizzleYZXW<T> {
    fn yzxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZXW<T> for S where
S: Y<T> + Z<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.x(), *self.w())
    }
}
pub trait SwizzleYZYX<T> {
    fn yzyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZYX<T> for S where
S: Y<T> + Z<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.x())
    }
}
pub trait SwizzleYZYY<T> {
    fn yzyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZYY<T> for S where
S: Y<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.y())
    }
}
pub trait SwizzleYZYZ<T> {
    fn yzyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZYZ<T> for S where
S: Y<T> + Z<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.z())
    }
}
pub trait SwizzleYZYW<T> {
    fn yzyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZYW<T> for S where
S: Y<T> + Z<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.y(), *self.w())
    }
}
pub trait SwizzleYZZX<T> {
    fn yzzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZZX<T> for S where
S: Y<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.x())
    }
}
pub trait SwizzleYZZY<T> {
    fn yzzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZZY<T> for S where
S: Y<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.y())
    }
}
pub trait SwizzleYZZZ<T> {
    fn yzzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZZZ<T> for S where
S: Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.z())
    }
}
pub trait SwizzleYZZW<T> {
    fn yzzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZZW<T> for S where
S: Y<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.z(), *self.w())
    }
}
pub trait SwizzleYZWX<T> {
    fn yzwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZWX<T> for S where
S: Y<T> + Z<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn yzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.x())
    }
}
pub trait SwizzleYZWY<T> {
    fn yzwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZWY<T> for S where
S: Y<T> + Z<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn yzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.y())
    }
}
pub trait SwizzleYZWZ<T> {
    fn yzwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZWZ<T> for S where
S: Y<T> + Z<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn yzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.z())
    }
}
pub trait SwizzleYZWW<T> {
    fn yzww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYZWW<T> for S where
S: Y<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn yzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.z(), *self.w(), *self.w())
    }
}
pub trait SwizzleYWXX<T> {
    fn ywxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWXX<T> for S where
S: Y<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn ywxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.x())
    }
}
pub trait SwizzleYWXY<T> {
    fn ywxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWXY<T> for S where
S: Y<T> + W<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn ywxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.y())
    }
}
pub trait SwizzleYWXZ<T> {
    fn ywxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWXZ<T> for S where
S: Y<T> + W<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn ywxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.z())
    }
}
pub trait SwizzleYWXW<T> {
    fn ywxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWXW<T> for S where
S: Y<T> + W<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn ywxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.x(), *self.w())
    }
}
pub trait SwizzleYWYX<T> {
    fn ywyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWYX<T> for S where
S: Y<T> + W<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn ywyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.x())
    }
}
pub trait SwizzleYWYY<T> {
    fn ywyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWYY<T> for S where
S: Y<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn ywyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.y())
    }
}
pub trait SwizzleYWYZ<T> {
    fn ywyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWYZ<T> for S where
S: Y<T> + W<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn ywyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.z())
    }
}
pub trait SwizzleYWYW<T> {
    fn ywyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWYW<T> for S where
S: Y<T> + W<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn ywyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.y(), *self.w())
    }
}
pub trait SwizzleYWZX<T> {
    fn ywzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWZX<T> for S where
S: Y<T> + W<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn ywzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.x())
    }
}
pub trait SwizzleYWZY<T> {
    fn ywzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWZY<T> for S where
S: Y<T> + W<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn ywzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.y())
    }
}
pub trait SwizzleYWZZ<T> {
    fn ywzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWZZ<T> for S where
S: Y<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn ywzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.z())
    }
}
pub trait SwizzleYWZW<T> {
    fn ywzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWZW<T> for S where
S: Y<T> + W<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn ywzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.z(), *self.w())
    }
}
pub trait SwizzleYWWX<T> {
    fn ywwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWWX<T> for S where
S: Y<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn ywwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.x())
    }
}
pub trait SwizzleYWWY<T> {
    fn ywwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWWY<T> for S where
S: Y<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn ywwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.y())
    }
}
pub trait SwizzleYWWZ<T> {
    fn ywwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWWZ<T> for S where
S: Y<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn ywwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.z())
    }
}
pub trait SwizzleYWWW<T> {
    fn ywww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleYWWW<T> for S where
S: Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn ywww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.y(), *self.w(), *self.w(), *self.w())
    }
}
pub trait SwizzleZXXX<T> {
    fn zxxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXXX<T> for S where
S: Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.x())
    }
}
pub trait SwizzleZXXY<T> {
    fn zxxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXXY<T> for S where
S: Z<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.y())
    }
}
pub trait SwizzleZXXZ<T> {
    fn zxxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXXZ<T> for S where
S: Z<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.z())
    }
}
pub trait SwizzleZXXW<T> {
    fn zxxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXXW<T> for S where
S: Z<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.x(), *self.w())
    }
}
pub trait SwizzleZXYX<T> {
    fn zxyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXYX<T> for S where
S: Z<T> + X<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.x())
    }
}
pub trait SwizzleZXYY<T> {
    fn zxyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXYY<T> for S where
S: Z<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.y())
    }
}
pub trait SwizzleZXYZ<T> {
    fn zxyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXYZ<T> for S where
S: Z<T> + X<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.z())
    }
}
pub trait SwizzleZXYW<T> {
    fn zxyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXYW<T> for S where
S: Z<T> + X<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.y(), *self.w())
    }
}
pub trait SwizzleZXZX<T> {
    fn zxzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXZX<T> for S where
S: Z<T> + X<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.x())
    }
}
pub trait SwizzleZXZY<T> {
    fn zxzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXZY<T> for S where
S: Z<T> + X<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.y())
    }
}
pub trait SwizzleZXZZ<T> {
    fn zxzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXZZ<T> for S where
S: Z<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.z())
    }
}
pub trait SwizzleZXZW<T> {
    fn zxzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXZW<T> for S where
S: Z<T> + X<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.z(), *self.w())
    }
}
pub trait SwizzleZXWX<T> {
    fn zxwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXWX<T> for S where
S: Z<T> + X<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.x())
    }
}
pub trait SwizzleZXWY<T> {
    fn zxwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXWY<T> for S where
S: Z<T> + X<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.y())
    }
}
pub trait SwizzleZXWZ<T> {
    fn zxwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXWZ<T> for S where
S: Z<T> + X<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.z())
    }
}
pub trait SwizzleZXWW<T> {
    fn zxww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZXWW<T> for S where
S: Z<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.x(), *self.w(), *self.w())
    }
}
pub trait SwizzleZYXX<T> {
    fn zyxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYXX<T> for S where
S: Z<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.x())
    }
}
pub trait SwizzleZYXY<T> {
    fn zyxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYXY<T> for S where
S: Z<T> + Y<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.y())
    }
}
pub trait SwizzleZYXZ<T> {
    fn zyxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYXZ<T> for S where
S: Z<T> + Y<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.z())
    }
}
pub trait SwizzleZYXW<T> {
    fn zyxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYXW<T> for S where
S: Z<T> + Y<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.x(), *self.w())
    }
}
pub trait SwizzleZYYX<T> {
    fn zyyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYYX<T> for S where
S: Z<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.x())
    }
}
pub trait SwizzleZYYY<T> {
    fn zyyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYYY<T> for S where
S: Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.y())
    }
}
pub trait SwizzleZYYZ<T> {
    fn zyyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYYZ<T> for S where
S: Z<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.z())
    }
}
pub trait SwizzleZYYW<T> {
    fn zyyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYYW<T> for S where
S: Z<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.y(), *self.w())
    }
}
pub trait SwizzleZYZX<T> {
    fn zyzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYZX<T> for S where
S: Z<T> + Y<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.x())
    }
}
pub trait SwizzleZYZY<T> {
    fn zyzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYZY<T> for S where
S: Z<T> + Y<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.y())
    }
}
pub trait SwizzleZYZZ<T> {
    fn zyzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYZZ<T> for S where
S: Z<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.z())
    }
}
pub trait SwizzleZYZW<T> {
    fn zyzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYZW<T> for S where
S: Z<T> + Y<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.z(), *self.w())
    }
}
pub trait SwizzleZYWX<T> {
    fn zywx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYWX<T> for S where
S: Z<T> + Y<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.x())
    }
}
pub trait SwizzleZYWY<T> {
    fn zywy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYWY<T> for S where
S: Z<T> + Y<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.y())
    }
}
pub trait SwizzleZYWZ<T> {
    fn zywz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYWZ<T> for S where
S: Z<T> + Y<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.z())
    }
}
pub trait SwizzleZYWW<T> {
    fn zyww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZYWW<T> for S where
S: Z<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.y(), *self.w(), *self.w())
    }
}
pub trait SwizzleZZXX<T> {
    fn zzxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZXX<T> for S where
S: Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.x())
    }
}
pub trait SwizzleZZXY<T> {
    fn zzxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZXY<T> for S where
S: Z<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.y())
    }
}
pub trait SwizzleZZXZ<T> {
    fn zzxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZXZ<T> for S where
S: Z<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.z())
    }
}
pub trait SwizzleZZXW<T> {
    fn zzxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZXW<T> for S where
S: Z<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.x(), *self.w())
    }
}
pub trait SwizzleZZYX<T> {
    fn zzyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZYX<T> for S where
S: Z<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.x())
    }
}
pub trait SwizzleZZYY<T> {
    fn zzyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZYY<T> for S where
S: Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.y())
    }
}
pub trait SwizzleZZYZ<T> {
    fn zzyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZYZ<T> for S where
S: Z<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.z())
    }
}
pub trait SwizzleZZYW<T> {
    fn zzyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZYW<T> for S where
S: Z<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.y(), *self.w())
    }
}
pub trait SwizzleZZZX<T> {
    fn zzzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZZX<T> for S where
S: Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.x())
    }
}
pub trait SwizzleZZZY<T> {
    fn zzzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZZY<T> for S where
S: Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.y())
    }
}
pub trait SwizzleZZZZ<T> {
    fn zzzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZZZ<T> for S where
S: Z<T>,
T: Copy {
    #[inline(always)]
    fn zzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.z())
    }
}
pub trait SwizzleZZZW<T> {
    fn zzzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZZW<T> for S where
S: Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.z(), *self.w())
    }
}
pub trait SwizzleZZWX<T> {
    fn zzwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZWX<T> for S where
S: Z<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.x())
    }
}
pub trait SwizzleZZWY<T> {
    fn zzwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZWY<T> for S where
S: Z<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.y())
    }
}
pub trait SwizzleZZWZ<T> {
    fn zzwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZWZ<T> for S where
S: Z<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.z())
    }
}
pub trait SwizzleZZWW<T> {
    fn zzww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZZWW<T> for S where
S: Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.z(), *self.w(), *self.w())
    }
}
pub trait SwizzleZWXX<T> {
    fn zwxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWXX<T> for S where
S: Z<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zwxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.x())
    }
}
pub trait SwizzleZWXY<T> {
    fn zwxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWXY<T> for S where
S: Z<T> + W<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zwxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.y())
    }
}
pub trait SwizzleZWXZ<T> {
    fn zwxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWXZ<T> for S where
S: Z<T> + W<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zwxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.z())
    }
}
pub trait SwizzleZWXW<T> {
    fn zwxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWXW<T> for S where
S: Z<T> + W<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zwxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.x(), *self.w())
    }
}
pub trait SwizzleZWYX<T> {
    fn zwyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWYX<T> for S where
S: Z<T> + W<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zwyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.x())
    }
}
pub trait SwizzleZWYY<T> {
    fn zwyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWYY<T> for S where
S: Z<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zwyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.y())
    }
}
pub trait SwizzleZWYZ<T> {
    fn zwyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWYZ<T> for S where
S: Z<T> + W<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zwyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.z())
    }
}
pub trait SwizzleZWYW<T> {
    fn zwyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWYW<T> for S where
S: Z<T> + W<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zwyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.y(), *self.w())
    }
}
pub trait SwizzleZWZX<T> {
    fn zwzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWZX<T> for S where
S: Z<T> + W<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zwzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.x())
    }
}
pub trait SwizzleZWZY<T> {
    fn zwzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWZY<T> for S where
S: Z<T> + W<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zwzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.y())
    }
}
pub trait SwizzleZWZZ<T> {
    fn zwzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWZZ<T> for S where
S: Z<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zwzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.z())
    }
}
pub trait SwizzleZWZW<T> {
    fn zwzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWZW<T> for S where
S: Z<T> + W<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zwzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.z(), *self.w())
    }
}
pub trait SwizzleZWWX<T> {
    fn zwwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWWX<T> for S where
S: Z<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn zwwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.x())
    }
}
pub trait SwizzleZWWY<T> {
    fn zwwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWWY<T> for S where
S: Z<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn zwwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.y())
    }
}
pub trait SwizzleZWWZ<T> {
    fn zwwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWWZ<T> for S where
S: Z<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn zwwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.z())
    }
}
pub trait SwizzleZWWW<T> {
    fn zwww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleZWWW<T> for S where
S: Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn zwww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.z(), *self.w(), *self.w(), *self.w())
    }
}
pub trait SwizzleWXXX<T> {
    fn wxxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXXX<T> for S where
S: W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wxxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.x())
    }
}
pub trait SwizzleWXXY<T> {
    fn wxxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXXY<T> for S where
S: W<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wxxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.y())
    }
}
pub trait SwizzleWXXZ<T> {
    fn wxxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXXZ<T> for S where
S: W<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wxxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.z())
    }
}
pub trait SwizzleWXXW<T> {
    fn wxxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXXW<T> for S where
S: W<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wxxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.x(), *self.w())
    }
}
pub trait SwizzleWXYX<T> {
    fn wxyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXYX<T> for S where
S: W<T> + X<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wxyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.x())
    }
}
pub trait SwizzleWXYY<T> {
    fn wxyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXYY<T> for S where
S: W<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wxyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.y())
    }
}
pub trait SwizzleWXYZ<T> {
    fn wxyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXYZ<T> for S where
S: W<T> + X<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wxyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.z())
    }
}
pub trait SwizzleWXYW<T> {
    fn wxyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXYW<T> for S where
S: W<T> + X<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wxyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.y(), *self.w())
    }
}
pub trait SwizzleWXZX<T> {
    fn wxzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXZX<T> for S where
S: W<T> + X<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wxzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.x())
    }
}
pub trait SwizzleWXZY<T> {
    fn wxzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXZY<T> for S where
S: W<T> + X<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wxzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.y())
    }
}
pub trait SwizzleWXZZ<T> {
    fn wxzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXZZ<T> for S where
S: W<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wxzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.z())
    }
}
pub trait SwizzleWXZW<T> {
    fn wxzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXZW<T> for S where
S: W<T> + X<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wxzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.z(), *self.w())
    }
}
pub trait SwizzleWXWX<T> {
    fn wxwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXWX<T> for S where
S: W<T> + X<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wxwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.x())
    }
}
pub trait SwizzleWXWY<T> {
    fn wxwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXWY<T> for S where
S: W<T> + X<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wxwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.y())
    }
}
pub trait SwizzleWXWZ<T> {
    fn wxwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXWZ<T> for S where
S: W<T> + X<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wxwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.z())
    }
}
pub trait SwizzleWXWW<T> {
    fn wxww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWXWW<T> for S where
S: W<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wxww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.x(), *self.w(), *self.w())
    }
}
pub trait SwizzleWYXX<T> {
    fn wyxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYXX<T> for S where
S: W<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wyxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.x())
    }
}
pub trait SwizzleWYXY<T> {
    fn wyxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYXY<T> for S where
S: W<T> + Y<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wyxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.y())
    }
}
pub trait SwizzleWYXZ<T> {
    fn wyxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYXZ<T> for S where
S: W<T> + Y<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wyxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.z())
    }
}
pub trait SwizzleWYXW<T> {
    fn wyxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYXW<T> for S where
S: W<T> + Y<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wyxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.x(), *self.w())
    }
}
pub trait SwizzleWYYX<T> {
    fn wyyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYYX<T> for S where
S: W<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wyyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.x())
    }
}
pub trait SwizzleWYYY<T> {
    fn wyyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYYY<T> for S where
S: W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wyyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.y())
    }
}
pub trait SwizzleWYYZ<T> {
    fn wyyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYYZ<T> for S where
S: W<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wyyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.z())
    }
}
pub trait SwizzleWYYW<T> {
    fn wyyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYYW<T> for S where
S: W<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wyyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.y(), *self.w())
    }
}
pub trait SwizzleWYZX<T> {
    fn wyzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYZX<T> for S where
S: W<T> + Y<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wyzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.x())
    }
}
pub trait SwizzleWYZY<T> {
    fn wyzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYZY<T> for S where
S: W<T> + Y<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wyzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.y())
    }
}
pub trait SwizzleWYZZ<T> {
    fn wyzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYZZ<T> for S where
S: W<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wyzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.z())
    }
}
pub trait SwizzleWYZW<T> {
    fn wyzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYZW<T> for S where
S: W<T> + Y<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wyzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.z(), *self.w())
    }
}
pub trait SwizzleWYWX<T> {
    fn wywx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYWX<T> for S where
S: W<T> + Y<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wywx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.x())
    }
}
pub trait SwizzleWYWY<T> {
    fn wywy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYWY<T> for S where
S: W<T> + Y<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wywy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.y())
    }
}
pub trait SwizzleWYWZ<T> {
    fn wywz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYWZ<T> for S where
S: W<T> + Y<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wywz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.z())
    }
}
pub trait SwizzleWYWW<T> {
    fn wyww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWYWW<T> for S where
S: W<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wyww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.y(), *self.w(), *self.w())
    }
}
pub trait SwizzleWZXX<T> {
    fn wzxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZXX<T> for S where
S: W<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wzxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.x())
    }
}
pub trait SwizzleWZXY<T> {
    fn wzxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZXY<T> for S where
S: W<T> + Z<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wzxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.y())
    }
}
pub trait SwizzleWZXZ<T> {
    fn wzxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZXZ<T> for S where
S: W<T> + Z<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wzxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.z())
    }
}
pub trait SwizzleWZXW<T> {
    fn wzxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZXW<T> for S where
S: W<T> + Z<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wzxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.x(), *self.w())
    }
}
pub trait SwizzleWZYX<T> {
    fn wzyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZYX<T> for S where
S: W<T> + Z<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wzyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.x())
    }
}
pub trait SwizzleWZYY<T> {
    fn wzyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZYY<T> for S where
S: W<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wzyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.y())
    }
}
pub trait SwizzleWZYZ<T> {
    fn wzyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZYZ<T> for S where
S: W<T> + Z<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wzyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.z())
    }
}
pub trait SwizzleWZYW<T> {
    fn wzyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZYW<T> for S where
S: W<T> + Z<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wzyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.y(), *self.w())
    }
}
pub trait SwizzleWZZX<T> {
    fn wzzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZZX<T> for S where
S: W<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wzzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.x())
    }
}
pub trait SwizzleWZZY<T> {
    fn wzzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZZY<T> for S where
S: W<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wzzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.y())
    }
}
pub trait SwizzleWZZZ<T> {
    fn wzzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZZZ<T> for S where
S: W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wzzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.z())
    }
}
pub trait SwizzleWZZW<T> {
    fn wzzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZZW<T> for S where
S: W<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wzzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.z(), *self.w())
    }
}
pub trait SwizzleWZWX<T> {
    fn wzwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZWX<T> for S where
S: W<T> + Z<T> + W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wzwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.x())
    }
}
pub trait SwizzleWZWY<T> {
    fn wzwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZWY<T> for S where
S: W<T> + Z<T> + W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wzwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.y())
    }
}
pub trait SwizzleWZWZ<T> {
    fn wzwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZWZ<T> for S where
S: W<T> + Z<T> + W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wzwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.z())
    }
}
pub trait SwizzleWZWW<T> {
    fn wzww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWZWW<T> for S where
S: W<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wzww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.z(), *self.w(), *self.w())
    }
}
pub trait SwizzleWWXX<T> {
    fn wwxx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWXX<T> for S where
S: W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wwxx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.x())
    }
}
pub trait SwizzleWWXY<T> {
    fn wwxy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWXY<T> for S where
S: W<T> + X<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wwxy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.y())
    }
}
pub trait SwizzleWWXZ<T> {
    fn wwxz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWXZ<T> for S where
S: W<T> + X<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wwxz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.z())
    }
}
pub trait SwizzleWWXW<T> {
    fn wwxw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWXW<T> for S where
S: W<T> + X<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wwxw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.x(), *self.w())
    }
}
pub trait SwizzleWWYX<T> {
    fn wwyx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWYX<T> for S where
S: W<T> + Y<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wwyx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.x())
    }
}
pub trait SwizzleWWYY<T> {
    fn wwyy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWYY<T> for S where
S: W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wwyy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.y())
    }
}
pub trait SwizzleWWYZ<T> {
    fn wwyz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWYZ<T> for S where
S: W<T> + Y<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wwyz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.z())
    }
}
pub trait SwizzleWWYW<T> {
    fn wwyw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWYW<T> for S where
S: W<T> + Y<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wwyw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.y(), *self.w())
    }
}
pub trait SwizzleWWZX<T> {
    fn wwzx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWZX<T> for S where
S: W<T> + Z<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wwzx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.x())
    }
}
pub trait SwizzleWWZY<T> {
    fn wwzy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWZY<T> for S where
S: W<T> + Z<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wwzy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.y())
    }
}
pub trait SwizzleWWZZ<T> {
    fn wwzz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWZZ<T> for S where
S: W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wwzz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.z())
    }
}
pub trait SwizzleWWZW<T> {
    fn wwzw(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWZW<T> for S where
S: W<T> + Z<T> + W<T>,
T: Copy {
    #[inline(always)]
    fn wwzw(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.z(), *self.w())
    }
}
pub trait SwizzleWWWX<T> {
    fn wwwx(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWWX<T> for S where
S: W<T> + X<T>,
T: Copy {
    #[inline(always)]
    fn wwwx(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.x())
    }
}
pub trait SwizzleWWWY<T> {
    fn wwwy(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWWY<T> for S where
S: W<T> + Y<T>,
T: Copy {
    #[inline(always)]
    fn wwwy(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.y())
    }
}
pub trait SwizzleWWWZ<T> {
    fn wwwz(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWWZ<T> for S where
S: W<T> + Z<T>,
T: Copy {
    #[inline(always)]
    fn wwwz(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.z())
    }
}
pub trait SwizzleWWWW<T> {
    fn wwww(&self) -> PolyVec4<T>;
}
impl<S, T> SwizzleWWWW<T> for S where
S: W<T>,
T: Copy {
    #[inline(always)]
    fn wwww(&self) -> PolyVec4<T> {
        PolyVec4::new(*self.w(), *self.w(), *self.w(), *self.w())
    }
}